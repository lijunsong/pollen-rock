#lang scribble/manual

@(require (for-label racket))
@(require scribble/decode)

@(define paramlist itemlist)
@(define (param
           #:name name
           #:type type
           #:optional [optional #f]
           . pre-content)
   (define optional-text (if optional " (optional)" ""))
   (define lead (tt (format "~a: ~a~a. "
                            name type optional-text)))
   (apply item
    `(,lead " " ,@pre-content)))

@(define (param-errno . str)
   (apply param str #:name "errno" #:type "int"))

@title{Pollen-rock: an improved Pollen server}

Pollen-rock improves Pollen web server by providing an interface for querying project configuration and file information. It also comes with a convenient in-browser editor that helps you compose and typeset your prose.

@;other-doc['(lib "pollen/scribblings/pollen.scrbl") #:indirect "Pollen"]

Pollen-rock is simply an add-on of Pollen rendering server. The new rendering server does not change Pollen language's semantics. Hate Pollen being silent on your undefined tag functions? You'll find the same behavior in Pollen-rock as well, because Pollen-rock uses Pollen to render your file. But Pollen-rock's built-in editor has the ability to inform you about that undefined tag, and you can make the decision what to do about it.

Internally, Pollen-rock provides a RESTful web API for querying various information of a Pollen project and source files. If you're interested in writing your tools using the RESTful API, continue to @secref["server-spec"]. If you're interested in Pollen-rock built-in editor, continue to @secref["installation"].

@local-table-of-contents[]

@section[#:tag "installation"]{Installation}

Pollen-rock is an add-on of Pollen. Installing pollen-rock is as simple as running the following command line in your terminal

@codeblock{
 raco pkg install pollen-rock
}

Racket will handle package dependencies for us.

For those who haven't installed Pollen before, you can follow the complete guide @secref["How_to_install" #:doc '(lib "pollen/scribblings/pollen.scrbl")] of Pollen to install Racket and Pollen, and then follow the above step.

@section[#:tag "use-server"]{Use Pollen-rock}

Working with Pollen-rock is similar to Pollen's @secref["The_project_server" #:doc '(lib "pollen/scribblings/pollen.scrbl")].

@subsection{Start the Server}

To start, issue the following command in your terminal.

@codeblock{
$ raco pollen-rock --start-dir ~/workspace/blog
}

And you'll see the following output

@verbatim{
Welcome to Pollen Rock 0.6.0 (Racket 6.8)
Project root is /home/user/workspace/blog/
Pollen Editor is running at http://localhost:8000 (accessible by all machines on your network)
Ctrl-C at any time to terminate Pollen Rock.
}

If @code{--start-dir} argument is not specified, the project root will be current working directory.

@margin-note{Your project directory will be accessible to all machines on your network. This is dangerous because other people who know your IP can issue HTTP POST request remotely to remove your project data. To limit the access scope to your own machine, specify @code{--local} in the argument.}

@section[#:tag "server-spec"]{Pollen-rock Server Specification}

Pollen-rock server provides
a set of RESTful APIs for the front end to query project information.

@margin-note{Note: these APIs and this doc are still under construction. They are subject to change at this point.}

@subsection[#:tag "working-example"]{Query the Server}

All API resource starts with @code{/rest/}. Let's take the following project structure as an working example.

@verbatim|{
/tmp/project/
  |- pollen.rkt
  |- file1.html.pm
  |- file2.html.pm
  |- dir1/
     |- file3.html.pm
  |- dir2/
}|

@margin-note{All JSON output in this section are additionally rendered by pretty print. The command output is generated by passing the JSON into @code{python -m json.tool}, as in @tt{curl http://localhost:8000/rest/fs/ | python -m json.tool}}

@code{file1.html.pm} and @code{file2.html.pm} are two pollen source file. pollen.rkt has the following contents

@verbatim|{
#lang racket

(provide (all-defined-out))

(define x 1)

(define (tag0 x . y)
  `(mytag ,x ,@y))
}|

Now open a terminal, and start pollen-rock

@verbatim{
$ raco pollen-rock
}

In another terminal, we can start querying the server. Let's list the project root directory

@verbatim|{
$ curl http://localhost:8000/rest/fs
{
  "errno": 0,
  "items": [
    "compiled/",
    "dir1/",
    "dir2/",
    "file1.html.pm",
    "file2.html.pm",
    "pollen.rkt"
  ]
}
}|

What about the @code{dir1} directory

@verbatim|{
$ curl http://localhost:8000/rest/fs/dir1
{
  "errno": 0,
  "items": [
    "file3.html.pm"
  ]
}
}|

What about listing some directory called @code{non-exists}?

@verbatim|{
$ curl http://localhost:8000/rest/fs/non-exists
{
  "errno": 1
}
}|

Let's read the contents of @code{file3.html.pm}

@verbatim|{
$ curl http://localhost:8000/rest/fs/dir1/file3.html.pm
{
  "errno": 0,
  "contents": "#lang pollen\n\nfile3 contents\n"
}
}|

Let's get all tags that visible in @code{file3.html.pm}.

@verbatim|{
$ curl http://localhost:8000/rest/tags/dir1/file3.html.pm
{
  "errno": 0,
  "tags": [
    {
      "arity-at-least": true,
      "kind": "procedure",
      "arity": 1,
      "required-keywords": [
        
      ],
      "name": "tag0",
      "all-keywords": [
        
      ]
    },
    {
      "kind": "variable",
      "name": "x",
      "type": "number",
      "value": 1
    }
  ]
}
}|

You can tell Pollen-rock can do quite a bit here. Let's dive into the API specification in next section.

@subsection[#:tag "api"]{RESTful API}

Pollen-rock supports requests that are form-url-encoded, i.e. requests whose @code{Content-Type} is @code{application/x-www-form-urlencoded}.

For each API, we first list its designated Url (the resource), and then query parameter, request parameter, and response parameter. It's necessary to make it clear what and where these parameters are in the request and response:

@itemlist[
 @item{@emph{query parameter} (@emph{GET} HTTP request only): It's the @code|{{6}}| and @code|{{7}}| of the following diagram (borrowed from
 @secref["URL_Structure" #:doc '(lib "net/scribblings/net.scrbl")])
  @verbatim|{
  http://sky@www:801/cgi-bin/finger;xyz?name=shriram;host=nw#top
                                    {6} {----7-------------}
            }|
  }

 @item{@emph{request parameter} (@emph{POST} HTTP request only): @emph{request parameter} is in the payload of an HTTP POST request. Pollen-rock currently supports only @code{application/x-www-form-urlencoded}.
 }

 @item{@emph{response parameter}: Response from the server. Pollen-rock now returns only JSON. So all the parameters are keys (properties) of JSON object.}
 ]

@subsubsection{POST /rest/fs/$path}

This API is for file system operations.

query parameter: None

request parameter:

@paramlist[
 @param[#:name "op" #:type "string"]{
   It can be one of
   @itemlist[@item{@tt{"mv"}: rename @tt{$path} into the string given in @tt{data}}
             @item{@tt{"mkdir"}: create new directory in this location}
             @item{@tt{"rm"}: remove the resource}
             @item{@tt{"write"}: put @tt{data} into file @tt{$path}}
             ]
 }
 @param[#:name "data" #:type "string" #:optional #t]{
   extra data
 }                                                            
 ]

response parameter:
@paramlist[
 @param[#:name "errno" #:type "int"]{0 means no error}
 @param[#:name "message" #:type "string"]{Extra message from server}
 ]

Examples: Create directory @code{dir3}, and move @code{dir3} to @code{dir4}.

@verbatim|{
$ curl -X POST -d "op=mkdir" http://localhost:8000/rest/fs/dir3
{
    "errno": 0,
    "message": ""
}
$ curl http://localhost:8000/rest/fs/
{
    "errno": 0,
    "items": [
        "compiled/",
        "dir1/",
        "dir2/",
        "dir3/",
        "file1.html.pm",
        "file2.html.pm",
        "pollen.rkt"
    ]
}
$ curl -X POST -d "op=mv&data=dir4" http://localhost:8000/rest/fs/dir3
{
    "errno": 0,
    "message": ""
}
}|

@subsubsection{GET /rest/fs/$path}

This API is for list directory or reading files.

query parameter: None

response parameter:
@paramlist[
 @param-errno{0 means success. non-zero means the operation fails}
 @param[#:name "items" #:type "string array"]{If @tt{$path} is a directory, @tt{items} contains the directory contents. All subdirectory names have @tt{/} suffix.}
 @param[#:name "contents" #:type "string"]{If @tt{$path} is a regular text file, @tt{contents} is the contents of that file.}
 ]

Examples: Get the contents of @tt{file3.html.pm}

@verbatim|{
$ curl http://localhost:8000/rest/fs/dir1/file3.html.pm
{
    "contents": "#lang pollen\n\nfile3 contents\n",
    "errno": 0
}
}|

List the project root
@verbatim|{
{
    "errno": 0,
    "items": [
        "compiled/",
        "dir1/",
        "dir2/",
        "dir3/",
        "dir4/",
        "file1.html",
        "file1.html.pm",
        "file2.html.pm",
        "pollen.rkt"
    ]
}
}|

@subsubsection[#:tag "api-tags"]{GET /rest/tags/$file}

Fetch defined tags of a racket module @code{$file}. Note that @code{$file} must be a racket module.

query parameter: None
@margin-note{It would be useful to accept a query parameter to return a specific tag}

response parameter:
@paramlist[
 @param-errno{0 means success. 1 means that error has occurred.}
 @param[#:name "tags" #:type "objects array"]{
  array of json objects containing procedure or variable information.
  @paramlist[
 @param[#:name "name" #:type "string"]{Tag name}
 @param[#:name "kind" #:type "string"]{Either @tt{"variable"} or @tt{"procedure"}}
 @param[#:name "type" #:type "string or null"]{Variable only. Valid values are @tt{"boolean"}, @tt{"number"}, @tt{"string"}, @tt{"char"}, @tt{"symbol"}, @tt{null}. Also see @tt{value}}
 @param[#:name "value" #:type "any"]{Variable only. The value of the tag. The type of the value is indicated by the @tt{type} property}
 @param[#:name "arity" #:type "number"]{Procedure only. This is the arity of the procedure. If @tt{arity-at-least} is @tt{true}, this value is the minimum arity that this procedure requires.}
 @param[#:name "arity-at-least" #:type "boolean"]{Procedure only. See @tt{arity}.}
 @param[#:name "all-keywords" #:type "string array or false"]{Procedure only. All keywords of a procedure, including optional and required keywords}
 @param[#:name "required-keywords" #:type "string array"]{Procedure only. required keywords}
 ]
 }
 ]

Examples: To fetch all tags exported to @code{file1.html.pm}
@verbatim|{
$ curl http://localhost:8000/rest/tags/file1.html.pm
{
    "errno": 0,
    "tags": [
        {
            "all-keywords": [],
            "arity": 1,
            "arity-at-least": true,
            "kind": "procedure",
            "name": "tag0",
            "required-keywords": []
        },
        {
            "kind": "variable",
            "name": "x",
            "type": "number",
            "value": 1
        }
    ]
}
}|
  
@subsubsection{GET /rest/config/$file}

Get project configuration of the given @tt{$file}. If @tt{pollen.rkt} doesn't exist, this API fetches pre-defined tags of @tt{pollen/setup}.

query parameter: None
@margin-note{It would be useful to accept a query parameter to return a specific config}

response parameter: same as @secref{api-tags}. However, this API returns only variables of the setup module.

@subsubsection{GET /rest/watch/$file}
Do HTTP long polling on the given @code{$file}. The HTTP request returns only when the modified time of @tt{$file} has changed.

query parameter:
@paramlist[
 @param[#:name "mtime" #:type "int" #:optional #t]{return immediately if the last modified time of the file is greater than this mtime.}
 ]

response parameter:
@paramlist[
 @param-errno{0 means file changed. 1 means no such file.}
 @param[#:name "mtime" #:type "int"]{Last modified time when errno is 0. When errno is 1, mtime can be anything}
 ]

Example: The following command would block until @code{touch file1.html.pm} runs.

@verbatim|{
$ (sleep 10 && touch file1.html.pm) &

$ time curl http://localhost:8000/rest/watch/file1.html.pm
{"mtime":1514347321,"errno":0}

real	0m9.445s
user	0m0.012s
sys	0m0.021s
}|

@subsubsection{GET /rest/render/$file}
Render the given pollen source @tt{$file}

query parameter: None

response parameter:
@paramlist[
 @param-errno{0 means no error, 1 means no such file, 2 means render failed.}
 @param[#:name "location" #:type "string or false"]{Rendered file name if errno is 0}
 ]

Example: render @tt{file3.html.pm}.

@verbatim|{
$ curl http://localhost:8000/rest/render/dir1/file3.html.pm
{
    "errno": 0,
    "location": "dir1/file3.html"
}
}|

@section[#:tag "frontend"]{Pollen-rock editor}

Pollen-Rock also comes with a built-in editor that makes it easy to
edit text mixed with racket code.
