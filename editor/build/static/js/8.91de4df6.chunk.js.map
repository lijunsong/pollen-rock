{"version":3,"sources":["../node_modules/codemirror/mode/asciiarmor/asciiarmor.js"],"names":["CodeMirror","errorIfNotEmpty","stream","nonWS","match","skipToEnd","defineMode","token","state","m","sol","type","result","eatWhile","next","blankLine","startState","defineMIME","mod","__webpack_require__"],"mappings":"8EAOC,SAAAA,GACD,aAEA,SAAAC,EAAAC,GACA,IAAAC,EAAAD,EAAAE,MAAA,UAEA,OADAF,EAAAG,YACAF,EAAA,aAGAH,EAAAM,WAAA,wBACA,OACAC,MAAA,SAAAL,EAAAM,GACA,IAAAC,EAEA,UAAAD,QACA,OAAAN,EAAAQ,QAAAD,EAAAP,EAAAE,MAAA,gCACAI,QAAA,UACAA,EAAAG,KAAAF,EAAA,GACA,OAGAR,EAAAC,GACS,cAAAM,QAAA,CACT,GAAAN,EAAAQ,OAAAR,EAAAE,MAAA,SAEA,OADAI,QAAA,SACA,OAEA,IAAAI,EAAAX,EAAAC,GAEA,OADAU,IAAAJ,QAAA,QACAI,EAES,gBAAAJ,SACTN,EAAAG,YACAG,QAAA,UACA,UACS,QAAAA,QACTN,EAAAQ,QAAAD,EAAAP,EAAAE,MAAA,6BACAK,EAAA,IAAAD,EAAAG,KAAA,SACAH,QAAA,MACA,OAEAN,EAAAW,SAAA,mBACA,MAEAX,EAAAY,OACA,SAGS,OAAAN,QACTP,EAAAC,QADS,GAITa,UAAA,SAAAP,GACA,WAAAA,kBAAA,SAEAQ,WAAA,WACA,OACAR,MAAA,MACAG,KAAA,UAKAX,EAAAiB,WAAA,gCACAjB,EAAAiB,WAAA,0CACAjB,EAAAiB,WAAA,qCACAjB,EAAAiB,WAAA,0CArEAC,CAAQC,EAAQ","file":"static/js/8.91de4df6.chunk.js","sourcesContent":["// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n(function (mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);else // Plain browser env\n    mod(CodeMirror);\n})(function (CodeMirror) {\n  \"use strict\";\n\n  function errorIfNotEmpty(stream) {\n    var nonWS = stream.match(/^\\s*\\S/);\n    stream.skipToEnd();\n    return nonWS ? \"error\" : null;\n  }\n\n  CodeMirror.defineMode(\"asciiarmor\", function () {\n    return {\n      token: function token(stream, state) {\n        var m;\n\n        if (state.state == \"top\") {\n          if (stream.sol() && (m = stream.match(/^-----BEGIN (.*)?-----\\s*$/))) {\n            state.state = \"headers\";\n            state.type = m[1];\n            return \"tag\";\n          }\n\n          return errorIfNotEmpty(stream);\n        } else if (state.state == \"headers\") {\n          if (stream.sol() && stream.match(/^\\w+:/)) {\n            state.state = \"header\";\n            return \"atom\";\n          } else {\n            var result = errorIfNotEmpty(stream);\n            if (result) state.state = \"body\";\n            return result;\n          }\n        } else if (state.state == \"header\") {\n          stream.skipToEnd();\n          state.state = \"headers\";\n          return \"string\";\n        } else if (state.state == \"body\") {\n          if (stream.sol() && (m = stream.match(/^-----END (.*)?-----\\s*$/))) {\n            if (m[1] != state.type) return \"error\";\n            state.state = \"end\";\n            return \"tag\";\n          } else {\n            if (stream.eatWhile(/[A-Za-z0-9+\\/=]/)) {\n              return null;\n            } else {\n              stream.next();\n              return \"error\";\n            }\n          }\n        } else if (state.state == \"end\") {\n          return errorIfNotEmpty(stream);\n        }\n      },\n      blankLine: function blankLine(state) {\n        if (state.state == \"headers\") state.state = \"body\";\n      },\n      startState: function startState() {\n        return {\n          state: \"top\",\n          type: null\n        };\n      }\n    };\n  });\n  CodeMirror.defineMIME(\"application/pgp\", \"asciiarmor\");\n  CodeMirror.defineMIME(\"application/pgp-encrypted\", \"asciiarmor\");\n  CodeMirror.defineMIME(\"application/pgp-keys\", \"asciiarmor\");\n  CodeMirror.defineMIME(\"application/pgp-signature\", \"asciiarmor\");\n});"],"sourceRoot":""}