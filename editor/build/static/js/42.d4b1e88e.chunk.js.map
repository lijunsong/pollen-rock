{"version":3,"sources":["../node_modules/codemirror/mode/haxe/haxe.js"],"names":["CodeMirror","defineMode","config","parserConfig","indentUnit","kw","type","style","content","A","B","C","operator","atom","attribute","keywords","if","while","else","do","try","return","break","continue","new","throw","var","inline","static","using","public","private","cast","import","macro","function","catch","untyped","callback","for","switch","case","default","in","never","trace","class","abstract","enum","interface","typedef","extends","implements","dynamic","true","false","null","isOperatorChar","chain","stream","state","f","tokenize","toUnescaped","end","next","escaped","ret","tp","cont","haxeTokenBase","ch","quote","test","eat","eatWhile","match","reAllowed","haxeTokenComment","skipToEnd","current","word","known","propertyIsEnumerable","kwAllowed","maybeEnd","atomicTypes","number","variable","string","regexp","HaxeLexical","indented","column","align","prev","info","this","inScope","varname","v","localVars","name","imported","typename","charAt","len","importedtypes","length","i","registerimport","importname","cx","t","marked","cc","pass","arguments","push","apply","inList","list","register","context","globalVars","defaultVars","pushcontext","vars","popcontext","pushlex","result","lexical","lex","poplex","expect","wanted","statement","metadef","vardef1","expression","block","maybeattribute","functiondef","forspec1","maybelabel","funarg","importdef","hasOwnProperty","maybeoperator","maybeexpression","commasep","objprop","value","property","metaargs","what","proceed","typeuse","vardef2","forin","_type","typestring","typeprop","startState","basecolumn","token","sol","indentation","eatSpace","combinator","pop","parseHaxe","indent","textAfter","firstChar","closing","electricChars","blockCommentStart","blockCommentEnd","lineComment","defineMIME","define","inString","peek","skipTo","mod","__webpack_require__"],"mappings":"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","file":"static/js/42.d4b1e88e.chunk.js","sourcesContent":["// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n(function (mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);else // Plain browser env\n    mod(CodeMirror);\n})(function (CodeMirror) {\n  \"use strict\";\n\n  CodeMirror.defineMode(\"haxe\", function (config, parserConfig) {\n    var indentUnit = config.indentUnit; // Tokenizer\n\n    function kw(type) {\n      return {\n        type: type,\n        style: \"keyword\"\n      };\n    }\n\n    var A = kw(\"keyword a\"),\n        B = kw(\"keyword b\"),\n        C = kw(\"keyword c\");\n    var operator = kw(\"operator\"),\n        atom = {\n      type: \"atom\",\n      style: \"atom\"\n    },\n        attribute = {\n      type: \"attribute\",\n      style: \"attribute\"\n    };\n    var type = kw(\"typedef\");\n    var keywords = {\n      \"if\": A,\n      \"while\": A,\n      \"else\": B,\n      \"do\": B,\n      \"try\": B,\n      \"return\": C,\n      \"break\": C,\n      \"continue\": C,\n      \"new\": C,\n      \"throw\": C,\n      \"var\": kw(\"var\"),\n      \"inline\": attribute,\n      \"static\": attribute,\n      \"using\": kw(\"import\"),\n      \"public\": attribute,\n      \"private\": attribute,\n      \"cast\": kw(\"cast\"),\n      \"import\": kw(\"import\"),\n      \"macro\": kw(\"macro\"),\n      \"function\": kw(\"function\"),\n      \"catch\": kw(\"catch\"),\n      \"untyped\": kw(\"untyped\"),\n      \"callback\": kw(\"cb\"),\n      \"for\": kw(\"for\"),\n      \"switch\": kw(\"switch\"),\n      \"case\": kw(\"case\"),\n      \"default\": kw(\"default\"),\n      \"in\": operator,\n      \"never\": kw(\"property_access\"),\n      \"trace\": kw(\"trace\"),\n      \"class\": type,\n      \"abstract\": type,\n      \"enum\": type,\n      \"interface\": type,\n      \"typedef\": type,\n      \"extends\": type,\n      \"implements\": type,\n      \"dynamic\": type,\n      \"true\": atom,\n      \"false\": atom,\n      \"null\": atom\n    };\n    var isOperatorChar = /[+\\-*&%=<>!?|]/;\n\n    function chain(stream, state, f) {\n      state.tokenize = f;\n      return f(stream, state);\n    }\n\n    function toUnescaped(stream, end) {\n      var escaped = false,\n          next;\n\n      while ((next = stream.next()) != null) {\n        if (next == end && !escaped) return true;\n        escaped = !escaped && next == \"\\\\\";\n      }\n    } // Used as scratch variables to communicate multiple values without\n    // consing up tons of objects.\n\n\n    var type, content;\n\n    function ret(tp, style, cont) {\n      type = tp;\n      content = cont;\n      return style;\n    }\n\n    function haxeTokenBase(stream, state) {\n      var ch = stream.next();\n\n      if (ch == '\"' || ch == \"'\") {\n        return chain(stream, state, haxeTokenString(ch));\n      } else if (/[\\[\\]{}\\(\\),;\\:\\.]/.test(ch)) {\n        return ret(ch);\n      } else if (ch == \"0\" && stream.eat(/x/i)) {\n        stream.eatWhile(/[\\da-f]/i);\n        return ret(\"number\", \"number\");\n      } else if (/\\d/.test(ch) || ch == \"-\" && stream.eat(/\\d/)) {\n        stream.match(/^\\d*(?:\\.\\d*(?!\\.))?(?:[eE][+\\-]?\\d+)?/);\n        return ret(\"number\", \"number\");\n      } else if (state.reAllowed && ch == \"~\" && stream.eat(/\\//)) {\n        toUnescaped(stream, \"/\");\n        stream.eatWhile(/[gimsu]/);\n        return ret(\"regexp\", \"string-2\");\n      } else if (ch == \"/\") {\n        if (stream.eat(\"*\")) {\n          return chain(stream, state, haxeTokenComment);\n        } else if (stream.eat(\"/\")) {\n          stream.skipToEnd();\n          return ret(\"comment\", \"comment\");\n        } else {\n          stream.eatWhile(isOperatorChar);\n          return ret(\"operator\", null, stream.current());\n        }\n      } else if (ch == \"#\") {\n        stream.skipToEnd();\n        return ret(\"conditional\", \"meta\");\n      } else if (ch == \"@\") {\n        stream.eat(/:/);\n        stream.eatWhile(/[\\w_]/);\n        return ret(\"metadata\", \"meta\");\n      } else if (isOperatorChar.test(ch)) {\n        stream.eatWhile(isOperatorChar);\n        return ret(\"operator\", null, stream.current());\n      } else {\n        var word;\n\n        if (/[A-Z]/.test(ch)) {\n          stream.eatWhile(/[\\w_<>]/);\n          word = stream.current();\n          return ret(\"type\", \"variable-3\", word);\n        } else {\n          stream.eatWhile(/[\\w_]/);\n          var word = stream.current(),\n              known = keywords.propertyIsEnumerable(word) && keywords[word];\n          return known && state.kwAllowed ? ret(known.type, known.style, word) : ret(\"variable\", \"variable\", word);\n        }\n      }\n    }\n\n    function haxeTokenString(quote) {\n      return function (stream, state) {\n        if (toUnescaped(stream, quote)) state.tokenize = haxeTokenBase;\n        return ret(\"string\", \"string\");\n      };\n    }\n\n    function haxeTokenComment(stream, state) {\n      var maybeEnd = false,\n          ch;\n\n      while (ch = stream.next()) {\n        if (ch == \"/\" && maybeEnd) {\n          state.tokenize = haxeTokenBase;\n          break;\n        }\n\n        maybeEnd = ch == \"*\";\n      }\n\n      return ret(\"comment\", \"comment\");\n    } // Parser\n\n\n    var atomicTypes = {\n      \"atom\": true,\n      \"number\": true,\n      \"variable\": true,\n      \"string\": true,\n      \"regexp\": true\n    };\n\n    function HaxeLexical(indented, column, type, align, prev, info) {\n      this.indented = indented;\n      this.column = column;\n      this.type = type;\n      this.prev = prev;\n      this.info = info;\n      if (align != null) this.align = align;\n    }\n\n    function inScope(state, varname) {\n      for (var v = state.localVars; v; v = v.next) {\n        if (v.name == varname) return true;\n      }\n    }\n\n    function parseHaxe(state, style, type, content, stream) {\n      var cc = state.cc; // Communicate our context to the combinators.\n      // (Less wasteful than consing up a hundred closures on every call.)\n\n      cx.state = state;\n      cx.stream = stream;\n      cx.marked = null, cx.cc = cc;\n      if (!state.lexical.hasOwnProperty(\"align\")) state.lexical.align = true;\n\n      while (true) {\n        var combinator = cc.length ? cc.pop() : statement;\n\n        if (combinator(type, content)) {\n          while (cc.length && cc[cc.length - 1].lex) {\n            cc.pop()();\n          }\n\n          if (cx.marked) return cx.marked;\n          if (type == \"variable\" && inScope(state, content)) return \"variable-2\";\n          if (type == \"variable\" && imported(state, content)) return \"variable-3\";\n          return style;\n        }\n      }\n    }\n\n    function imported(state, typename) {\n      if (/[a-z]/.test(typename.charAt(0))) return false;\n      var len = state.importedtypes.length;\n\n      for (var i = 0; i < len; i++) {\n        if (state.importedtypes[i] == typename) return true;\n      }\n    }\n\n    function registerimport(importname) {\n      var state = cx.state;\n\n      for (var t = state.importedtypes; t; t = t.next) {\n        if (t.name == importname) return;\n      }\n\n      state.importedtypes = {\n        name: importname,\n        next: state.importedtypes\n      };\n    } // Combinator utils\n\n\n    var cx = {\n      state: null,\n      column: null,\n      marked: null,\n      cc: null\n    };\n\n    function pass() {\n      for (var i = arguments.length - 1; i >= 0; i--) {\n        cx.cc.push(arguments[i]);\n      }\n    }\n\n    function cont() {\n      pass.apply(null, arguments);\n      return true;\n    }\n\n    function inList(name, list) {\n      for (var v = list; v; v = v.next) {\n        if (v.name == name) return true;\n      }\n\n      return false;\n    }\n\n    function register(varname) {\n      var state = cx.state;\n\n      if (state.context) {\n        cx.marked = \"def\";\n        if (inList(varname, state.localVars)) return;\n        state.localVars = {\n          name: varname,\n          next: state.localVars\n        };\n      } else if (state.globalVars) {\n        if (inList(varname, state.globalVars)) return;\n        state.globalVars = {\n          name: varname,\n          next: state.globalVars\n        };\n      }\n    } // Combinators\n\n\n    var defaultVars = {\n      name: \"this\",\n      next: null\n    };\n\n    function pushcontext() {\n      if (!cx.state.context) cx.state.localVars = defaultVars;\n      cx.state.context = {\n        prev: cx.state.context,\n        vars: cx.state.localVars\n      };\n    }\n\n    function popcontext() {\n      cx.state.localVars = cx.state.context.vars;\n      cx.state.context = cx.state.context.prev;\n    }\n\n    popcontext.lex = true;\n\n    function pushlex(type, info) {\n      var result = function result() {\n        var state = cx.state;\n        state.lexical = new HaxeLexical(state.indented, cx.stream.column(), type, null, state.lexical, info);\n      };\n\n      result.lex = true;\n      return result;\n    }\n\n    function poplex() {\n      var state = cx.state;\n\n      if (state.lexical.prev) {\n        if (state.lexical.type == \")\") state.indented = state.lexical.indented;\n        state.lexical = state.lexical.prev;\n      }\n    }\n\n    poplex.lex = true;\n\n    function expect(wanted) {\n      function f(type) {\n        if (type == wanted) return cont();else if (wanted == \";\") return pass();else return cont(f);\n      }\n\n      return f;\n    }\n\n    function statement(type) {\n      if (type == \"@\") return cont(metadef);\n      if (type == \"var\") return cont(pushlex(\"vardef\"), vardef1, expect(\";\"), poplex);\n      if (type == \"keyword a\") return cont(pushlex(\"form\"), expression, statement, poplex);\n      if (type == \"keyword b\") return cont(pushlex(\"form\"), statement, poplex);\n      if (type == \"{\") return cont(pushlex(\"}\"), pushcontext, block, poplex, popcontext);\n      if (type == \";\") return cont();\n      if (type == \"attribute\") return cont(maybeattribute);\n      if (type == \"function\") return cont(functiondef);\n      if (type == \"for\") return cont(pushlex(\"form\"), expect(\"(\"), pushlex(\")\"), forspec1, expect(\")\"), poplex, statement, poplex);\n      if (type == \"variable\") return cont(pushlex(\"stat\"), maybelabel);\n      if (type == \"switch\") return cont(pushlex(\"form\"), expression, pushlex(\"}\", \"switch\"), expect(\"{\"), block, poplex, poplex);\n      if (type == \"case\") return cont(expression, expect(\":\"));\n      if (type == \"default\") return cont(expect(\":\"));\n      if (type == \"catch\") return cont(pushlex(\"form\"), pushcontext, expect(\"(\"), funarg, expect(\")\"), statement, poplex, popcontext);\n      if (type == \"import\") return cont(importdef, expect(\";\"));\n      if (type == \"typedef\") return cont(typedef);\n      return pass(pushlex(\"stat\"), expression, expect(\";\"), poplex);\n    }\n\n    function expression(type) {\n      if (atomicTypes.hasOwnProperty(type)) return cont(maybeoperator);\n      if (type == \"type\") return cont(maybeoperator);\n      if (type == \"function\") return cont(functiondef);\n      if (type == \"keyword c\") return cont(maybeexpression);\n      if (type == \"(\") return cont(pushlex(\")\"), maybeexpression, expect(\")\"), poplex, maybeoperator);\n      if (type == \"operator\") return cont(expression);\n      if (type == \"[\") return cont(pushlex(\"]\"), commasep(maybeexpression, \"]\"), poplex, maybeoperator);\n      if (type == \"{\") return cont(pushlex(\"}\"), commasep(objprop, \"}\"), poplex, maybeoperator);\n      return cont();\n    }\n\n    function maybeexpression(type) {\n      if (type.match(/[;\\}\\)\\],]/)) return pass();\n      return pass(expression);\n    }\n\n    function maybeoperator(type, value) {\n      if (type == \"operator\" && /\\+\\+|--/.test(value)) return cont(maybeoperator);\n      if (type == \"operator\" || type == \":\") return cont(expression);\n      if (type == \";\") return;\n      if (type == \"(\") return cont(pushlex(\")\"), commasep(expression, \")\"), poplex, maybeoperator);\n      if (type == \".\") return cont(property, maybeoperator);\n      if (type == \"[\") return cont(pushlex(\"]\"), expression, expect(\"]\"), poplex, maybeoperator);\n    }\n\n    function maybeattribute(type) {\n      if (type == \"attribute\") return cont(maybeattribute);\n      if (type == \"function\") return cont(functiondef);\n      if (type == \"var\") return cont(vardef1);\n    }\n\n    function metadef(type) {\n      if (type == \":\") return cont(metadef);\n      if (type == \"variable\") return cont(metadef);\n      if (type == \"(\") return cont(pushlex(\")\"), commasep(metaargs, \")\"), poplex, statement);\n    }\n\n    function metaargs(type) {\n      if (type == \"variable\") return cont();\n    }\n\n    function importdef(type, value) {\n      if (type == \"variable\" && /[A-Z]/.test(value.charAt(0))) {\n        registerimport(value);\n        return cont();\n      } else if (type == \"variable\" || type == \"property\" || type == \".\" || value == \"*\") return cont(importdef);\n    }\n\n    function typedef(type, value) {\n      if (type == \"variable\" && /[A-Z]/.test(value.charAt(0))) {\n        registerimport(value);\n        return cont();\n      } else if (type == \"type\" && /[A-Z]/.test(value.charAt(0))) {\n        return cont();\n      }\n    }\n\n    function maybelabel(type) {\n      if (type == \":\") return cont(poplex, statement);\n      return pass(maybeoperator, expect(\";\"), poplex);\n    }\n\n    function property(type) {\n      if (type == \"variable\") {\n        cx.marked = \"property\";\n        return cont();\n      }\n    }\n\n    function objprop(type) {\n      if (type == \"variable\") cx.marked = \"property\";\n      if (atomicTypes.hasOwnProperty(type)) return cont(expect(\":\"), expression);\n    }\n\n    function commasep(what, end) {\n      function proceed(type) {\n        if (type == \",\") return cont(what, proceed);\n        if (type == end) return cont();\n        return cont(expect(end));\n      }\n\n      return function (type) {\n        if (type == end) return cont();else return pass(what, proceed);\n      };\n    }\n\n    function block(type) {\n      if (type == \"}\") return cont();\n      return pass(statement, block);\n    }\n\n    function vardef1(type, value) {\n      if (type == \"variable\") {\n        register(value);\n        return cont(typeuse, vardef2);\n      }\n\n      return cont();\n    }\n\n    function vardef2(type, value) {\n      if (value == \"=\") return cont(expression, vardef2);\n      if (type == \",\") return cont(vardef1);\n    }\n\n    function forspec1(type, value) {\n      if (type == \"variable\") {\n        register(value);\n        return cont(forin, expression);\n      } else {\n        return pass();\n      }\n    }\n\n    function forin(_type, value) {\n      if (value == \"in\") return cont();\n    }\n\n    function functiondef(type, value) {\n      //function names starting with upper-case letters are recognised as types, so cludging them together here.\n      if (type == \"variable\" || type == \"type\") {\n        register(value);\n        return cont(functiondef);\n      }\n\n      if (value == \"new\") return cont(functiondef);\n      if (type == \"(\") return cont(pushlex(\")\"), pushcontext, commasep(funarg, \")\"), poplex, typeuse, statement, popcontext);\n    }\n\n    function typeuse(type) {\n      if (type == \":\") return cont(typestring);\n    }\n\n    function typestring(type) {\n      if (type == \"type\") return cont();\n      if (type == \"variable\") return cont();\n      if (type == \"{\") return cont(pushlex(\"}\"), commasep(typeprop, \"}\"), poplex);\n    }\n\n    function typeprop(type) {\n      if (type == \"variable\") return cont(typeuse);\n    }\n\n    function funarg(type, value) {\n      if (type == \"variable\") {\n        register(value);\n        return cont(typeuse);\n      }\n    } // Interface\n\n\n    return {\n      startState: function startState(basecolumn) {\n        var defaulttypes = [\"Int\", \"Float\", \"String\", \"Void\", \"Std\", \"Bool\", \"Dynamic\", \"Array\"];\n        var state = {\n          tokenize: haxeTokenBase,\n          reAllowed: true,\n          kwAllowed: true,\n          cc: [],\n          lexical: new HaxeLexical((basecolumn || 0) - indentUnit, 0, \"block\", false),\n          localVars: parserConfig.localVars,\n          importedtypes: defaulttypes,\n          context: parserConfig.localVars && {\n            vars: parserConfig.localVars\n          },\n          indented: 0\n        };\n        if (parserConfig.globalVars && typeof parserConfig.globalVars == \"object\") state.globalVars = parserConfig.globalVars;\n        return state;\n      },\n      token: function token(stream, state) {\n        if (stream.sol()) {\n          if (!state.lexical.hasOwnProperty(\"align\")) state.lexical.align = false;\n          state.indented = stream.indentation();\n        }\n\n        if (stream.eatSpace()) return null;\n        var style = state.tokenize(stream, state);\n        if (type == \"comment\") return style;\n        state.reAllowed = !!(type == \"operator\" || type == \"keyword c\" || type.match(/^[\\[{}\\(,;:]$/));\n        state.kwAllowed = type != '.';\n        return parseHaxe(state, style, type, content, stream);\n      },\n      indent: function indent(state, textAfter) {\n        if (state.tokenize != haxeTokenBase) return 0;\n        var firstChar = textAfter && textAfter.charAt(0),\n            lexical = state.lexical;\n        if (lexical.type == \"stat\" && firstChar == \"}\") lexical = lexical.prev;\n        var type = lexical.type,\n            closing = firstChar == type;\n        if (type == \"vardef\") return lexical.indented + 4;else if (type == \"form\" && firstChar == \"{\") return lexical.indented;else if (type == \"stat\" || type == \"form\") return lexical.indented + indentUnit;else if (lexical.info == \"switch\" && !closing) return lexical.indented + (/^(?:case|default)\\b/.test(textAfter) ? indentUnit : 2 * indentUnit);else if (lexical.align) return lexical.column + (closing ? 0 : 1);else return lexical.indented + (closing ? 0 : indentUnit);\n      },\n      electricChars: \"{}\",\n      blockCommentStart: \"/*\",\n      blockCommentEnd: \"*/\",\n      lineComment: \"//\"\n    };\n  });\n  CodeMirror.defineMIME(\"text/x-haxe\", \"haxe\");\n  CodeMirror.defineMode(\"hxml\", function () {\n    return {\n      startState: function startState() {\n        return {\n          define: false,\n          inString: false\n        };\n      },\n      token: function token(stream, state) {\n        var ch = stream.peek();\n        var sol = stream.sol(); ///* comments */\n\n        if (ch == \"#\") {\n          stream.skipToEnd();\n          return \"comment\";\n        }\n\n        if (sol && ch == \"-\") {\n          var style = \"variable-2\";\n          stream.eat(/-/);\n\n          if (stream.peek() == \"-\") {\n            stream.eat(/-/);\n            style = \"keyword a\";\n          }\n\n          if (stream.peek() == \"D\") {\n            stream.eat(/[D]/);\n            style = \"keyword c\";\n            state.define = true;\n          }\n\n          stream.eatWhile(/[A-Z]/i);\n          return style;\n        }\n\n        var ch = stream.peek();\n\n        if (state.inString == false && ch == \"'\") {\n          state.inString = true;\n          stream.next();\n        }\n\n        if (state.inString == true) {\n          if (stream.skipTo(\"'\")) {} else {\n            stream.skipToEnd();\n          }\n\n          if (stream.peek() == \"'\") {\n            stream.next();\n            state.inString = false;\n          }\n\n          return \"string\";\n        }\n\n        stream.next();\n        return null;\n      },\n      lineComment: \"#\"\n    };\n  });\n  CodeMirror.defineMIME(\"text/x-hxml\", \"hxml\");\n});"],"sourceRoot":""}