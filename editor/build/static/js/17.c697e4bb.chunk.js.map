{"version":3,"sources":["../node_modules/codemirror/mode/crystal/crystal.js"],"names":["CodeMirror","defineMode","config","wordRegExp","words","end","RegExp","join","chain","tokenize","stream","state","push","operators","conditionalOperators","indexingOperators","anotherOperators","idents","types","keywords","atomWords","indentKeywords","indentExpressionKeywords","dedentKeywordsArray","dedentKeywords","dedentPunctualsArray","dedentPunctuals","nextTokenizer","def","tokenFollowIdent","fun","macro","eatSpace","matched","match","eat","pop","class","tokenFollowType","module","struct","lib","enum","union","matching","[","{","(","<","tokenBase","lastToken","tokenMacro","peek","skipToEnd","current","test","blocks","indexOf","currentIndent","lastStyle","hasOwnProperty","tokenNest","tokenQuote","delim","style","embed","next","phrase","sol","escaped","tokenHereDoc","begin","started","length","nextStyle","ch","startState","token","indent","textAfter","replace","indentUnit","fold","electricInput","concat","lineComment","defineMIME","mod","__webpack_require__"],"mappings":"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","file":"static/js/17.c697e4bb.chunk.js","sourcesContent":["// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n(function (mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);else // Plain browser env\n    mod(CodeMirror);\n})(function (CodeMirror) {\n  \"use strict\";\n\n  CodeMirror.defineMode(\"crystal\", function (config) {\n    function wordRegExp(words, end) {\n      return new RegExp((end ? \"\" : \"^\") + \"(?:\" + words.join(\"|\") + \")\" + (end ? \"$\" : \"\\\\b\"));\n    }\n\n    function chain(tokenize, stream, state) {\n      state.tokenize.push(tokenize);\n      return tokenize(stream, state);\n    }\n\n    var operators = /^(?:[-+/%|&^]|\\*\\*?|[<>]{2})/;\n    var conditionalOperators = /^(?:[=!]~|===|<=>|[<>=!]=?|[|&]{2}|~)/;\n    var indexingOperators = /^(?:\\[\\][?=]?)/;\n    var anotherOperators = /^(?:\\.(?:\\.{2})?|->|[?:])/;\n    var idents = /^[a-z_\\u009F-\\uFFFF][a-zA-Z0-9_\\u009F-\\uFFFF]*/;\n    var types = /^[A-Z_\\u009F-\\uFFFF][a-zA-Z0-9_\\u009F-\\uFFFF]*/;\n    var keywords = wordRegExp([\"abstract\", \"alias\", \"as\", \"asm\", \"begin\", \"break\", \"case\", \"class\", \"def\", \"do\", \"else\", \"elsif\", \"end\", \"ensure\", \"enum\", \"extend\", \"for\", \"fun\", \"if\", \"include\", \"instance_sizeof\", \"lib\", \"macro\", \"module\", \"next\", \"of\", \"out\", \"pointerof\", \"private\", \"protected\", \"rescue\", \"return\", \"require\", \"select\", \"sizeof\", \"struct\", \"super\", \"then\", \"type\", \"typeof\", \"uninitialized\", \"union\", \"unless\", \"until\", \"when\", \"while\", \"with\", \"yield\", \"__DIR__\", \"__END_LINE__\", \"__FILE__\", \"__LINE__\"]);\n    var atomWords = wordRegExp([\"true\", \"false\", \"nil\", \"self\"]);\n    var indentKeywordsArray = [\"def\", \"fun\", \"macro\", \"class\", \"module\", \"struct\", \"lib\", \"enum\", \"union\", \"do\", \"for\"];\n    var indentKeywords = wordRegExp(indentKeywordsArray);\n    var indentExpressionKeywordsArray = [\"if\", \"unless\", \"case\", \"while\", \"until\", \"begin\", \"then\"];\n    var indentExpressionKeywords = wordRegExp(indentExpressionKeywordsArray);\n    var dedentKeywordsArray = [\"end\", \"else\", \"elsif\", \"rescue\", \"ensure\"];\n    var dedentKeywords = wordRegExp(dedentKeywordsArray);\n    var dedentPunctualsArray = [\"\\\\)\", \"\\\\}\", \"\\\\]\"];\n    var dedentPunctuals = new RegExp(\"^(?:\" + dedentPunctualsArray.join(\"|\") + \")$\");\n    var nextTokenizer = {\n      \"def\": tokenFollowIdent,\n      \"fun\": tokenFollowIdent,\n      \"macro\": tokenMacroDef,\n      \"class\": tokenFollowType,\n      \"module\": tokenFollowType,\n      \"struct\": tokenFollowType,\n      \"lib\": tokenFollowType,\n      \"enum\": tokenFollowType,\n      \"union\": tokenFollowType\n    };\n    var matching = {\n      \"[\": \"]\",\n      \"{\": \"}\",\n      \"(\": \")\",\n      \"<\": \">\"\n    };\n\n    function tokenBase(stream, state) {\n      if (stream.eatSpace()) {\n        return null;\n      } // Macros\n\n\n      if (state.lastToken != \"\\\\\" && stream.match(\"{%\", false)) {\n        return chain(tokenMacro(\"%\", \"%\"), stream, state);\n      }\n\n      if (state.lastToken != \"\\\\\" && stream.match(\"{{\", false)) {\n        return chain(tokenMacro(\"{\", \"}\"), stream, state);\n      } // Comments\n\n\n      if (stream.peek() == \"#\") {\n        stream.skipToEnd();\n        return \"comment\";\n      } // Variables and keywords\n\n\n      var matched;\n\n      if (stream.match(idents)) {\n        stream.eat(/[?!]/);\n        matched = stream.current();\n\n        if (stream.eat(\":\")) {\n          return \"atom\";\n        } else if (state.lastToken == \".\") {\n          return \"property\";\n        } else if (keywords.test(matched)) {\n          if (indentKeywords.test(matched)) {\n            if (!(matched == \"fun\" && state.blocks.indexOf(\"lib\") >= 0) && !(matched == \"def\" && state.lastToken == \"abstract\")) {\n              state.blocks.push(matched);\n              state.currentIndent += 1;\n            }\n          } else if ((state.lastStyle == \"operator\" || !state.lastStyle) && indentExpressionKeywords.test(matched)) {\n            state.blocks.push(matched);\n            state.currentIndent += 1;\n          } else if (matched == \"end\") {\n            state.blocks.pop();\n            state.currentIndent -= 1;\n          }\n\n          if (nextTokenizer.hasOwnProperty(matched)) {\n            state.tokenize.push(nextTokenizer[matched]);\n          }\n\n          return \"keyword\";\n        } else if (atomWords.test(matched)) {\n          return \"atom\";\n        }\n\n        return \"variable\";\n      } // Class variables and instance variables\n      // or attributes\n\n\n      if (stream.eat(\"@\")) {\n        if (stream.peek() == \"[\") {\n          return chain(tokenNest(\"[\", \"]\", \"meta\"), stream, state);\n        }\n\n        stream.eat(\"@\");\n        stream.match(idents) || stream.match(types);\n        return \"variable-2\";\n      } // Constants and types\n\n\n      if (stream.match(types)) {\n        return \"tag\";\n      } // Symbols or ':' operator\n\n\n      if (stream.eat(\":\")) {\n        if (stream.eat(\"\\\"\")) {\n          return chain(tokenQuote(\"\\\"\", \"atom\", false), stream, state);\n        } else if (stream.match(idents) || stream.match(types) || stream.match(operators) || stream.match(conditionalOperators) || stream.match(indexingOperators)) {\n          return \"atom\";\n        }\n\n        stream.eat(\":\");\n        return \"operator\";\n      } // Strings\n\n\n      if (stream.eat(\"\\\"\")) {\n        return chain(tokenQuote(\"\\\"\", \"string\", true), stream, state);\n      } // Strings or regexps or macro variables or '%' operator\n\n\n      if (stream.peek() == \"%\") {\n        var style = \"string\";\n        var embed = true;\n        var delim;\n\n        if (stream.match(\"%r\")) {\n          // Regexps\n          style = \"string-2\";\n          delim = stream.next();\n        } else if (stream.match(\"%w\")) {\n          embed = false;\n          delim = stream.next();\n        } else if (stream.match(\"%q\")) {\n          embed = false;\n          delim = stream.next();\n        } else {\n          if (delim = stream.match(/^%([^\\w\\s=])/)) {\n            delim = delim[1];\n          } else if (stream.match(/^%[a-zA-Z0-9_\\u009F-\\uFFFF]*/)) {\n            // Macro variables\n            return \"meta\";\n          } else {\n            // '%' operator\n            return \"operator\";\n          }\n        }\n\n        if (matching.hasOwnProperty(delim)) {\n          delim = matching[delim];\n        }\n\n        return chain(tokenQuote(delim, style, embed), stream, state);\n      } // Here Docs\n\n\n      if (matched = stream.match(/^<<-('?)([A-Z]\\w*)\\1/)) {\n        return chain(tokenHereDoc(matched[2], !matched[1]), stream, state);\n      } // Characters\n\n\n      if (stream.eat(\"'\")) {\n        stream.match(/^(?:[^']|\\\\(?:[befnrtv0'\"]|[0-7]{3}|u(?:[0-9a-fA-F]{4}|\\{[0-9a-fA-F]{1,6}\\})))/);\n        stream.eat(\"'\");\n        return \"atom\";\n      } // Numbers\n\n\n      if (stream.eat(\"0\")) {\n        if (stream.eat(\"x\")) {\n          stream.match(/^[0-9a-fA-F]+/);\n        } else if (stream.eat(\"o\")) {\n          stream.match(/^[0-7]+/);\n        } else if (stream.eat(\"b\")) {\n          stream.match(/^[01]+/);\n        }\n\n        return \"number\";\n      }\n\n      if (stream.eat(/^\\d/)) {\n        stream.match(/^\\d*(?:\\.\\d+)?(?:[eE][+-]?\\d+)?/);\n        return \"number\";\n      } // Operators\n\n\n      if (stream.match(operators)) {\n        stream.eat(\"=\"); // Operators can follow assign symbol.\n\n        return \"operator\";\n      }\n\n      if (stream.match(conditionalOperators) || stream.match(anotherOperators)) {\n        return \"operator\";\n      } // Parens and braces\n\n\n      if (matched = stream.match(/[({[]/, false)) {\n        matched = matched[0];\n        return chain(tokenNest(matched, matching[matched], null), stream, state);\n      } // Escapes\n\n\n      if (stream.eat(\"\\\\\")) {\n        stream.next();\n        return \"meta\";\n      }\n\n      stream.next();\n      return null;\n    }\n\n    function tokenNest(begin, end, style, started) {\n      return function (stream, state) {\n        if (!started && stream.match(begin)) {\n          state.tokenize[state.tokenize.length - 1] = tokenNest(begin, end, style, true);\n          state.currentIndent += 1;\n          return style;\n        }\n\n        var nextStyle = tokenBase(stream, state);\n\n        if (stream.current() === end) {\n          state.tokenize.pop();\n          state.currentIndent -= 1;\n          nextStyle = style;\n        }\n\n        return nextStyle;\n      };\n    }\n\n    function tokenMacro(begin, end, started) {\n      return function (stream, state) {\n        if (!started && stream.match(\"{\" + begin)) {\n          state.currentIndent += 1;\n          state.tokenize[state.tokenize.length - 1] = tokenMacro(begin, end, true);\n          return \"meta\";\n        }\n\n        if (stream.match(end + \"}\")) {\n          state.currentIndent -= 1;\n          state.tokenize.pop();\n          return \"meta\";\n        }\n\n        return tokenBase(stream, state);\n      };\n    }\n\n    function tokenMacroDef(stream, state) {\n      if (stream.eatSpace()) {\n        return null;\n      }\n\n      var matched;\n\n      if (matched = stream.match(idents)) {\n        if (matched == \"def\") {\n          return \"keyword\";\n        }\n\n        stream.eat(/[?!]/);\n      }\n\n      state.tokenize.pop();\n      return \"def\";\n    }\n\n    function tokenFollowIdent(stream, state) {\n      if (stream.eatSpace()) {\n        return null;\n      }\n\n      if (stream.match(idents)) {\n        stream.eat(/[!?]/);\n      } else {\n        stream.match(operators) || stream.match(conditionalOperators) || stream.match(indexingOperators);\n      }\n\n      state.tokenize.pop();\n      return \"def\";\n    }\n\n    function tokenFollowType(stream, state) {\n      if (stream.eatSpace()) {\n        return null;\n      }\n\n      stream.match(types);\n      state.tokenize.pop();\n      return \"def\";\n    }\n\n    function tokenQuote(end, style, embed) {\n      return function (stream, state) {\n        var escaped = false;\n\n        while (stream.peek()) {\n          if (!escaped) {\n            if (stream.match(\"{%\", false)) {\n              state.tokenize.push(tokenMacro(\"%\", \"%\"));\n              return style;\n            }\n\n            if (stream.match(\"{{\", false)) {\n              state.tokenize.push(tokenMacro(\"{\", \"}\"));\n              return style;\n            }\n\n            if (embed && stream.match(\"#{\", false)) {\n              state.tokenize.push(tokenNest(\"#{\", \"}\", \"meta\"));\n              return style;\n            }\n\n            var ch = stream.next();\n\n            if (ch == end) {\n              state.tokenize.pop();\n              return style;\n            }\n\n            escaped = embed && ch == \"\\\\\";\n          } else {\n            stream.next();\n            escaped = false;\n          }\n        }\n\n        return style;\n      };\n    }\n\n    function tokenHereDoc(phrase, embed) {\n      return function (stream, state) {\n        if (stream.sol()) {\n          stream.eatSpace();\n\n          if (stream.match(phrase)) {\n            state.tokenize.pop();\n            return \"string\";\n          }\n        }\n\n        var escaped = false;\n\n        while (stream.peek()) {\n          if (!escaped) {\n            if (stream.match(\"{%\", false)) {\n              state.tokenize.push(tokenMacro(\"%\", \"%\"));\n              return \"string\";\n            }\n\n            if (stream.match(\"{{\", false)) {\n              state.tokenize.push(tokenMacro(\"{\", \"}\"));\n              return \"string\";\n            }\n\n            if (embed && stream.match(\"#{\", false)) {\n              state.tokenize.push(tokenNest(\"#{\", \"}\", \"meta\"));\n              return \"string\";\n            }\n\n            escaped = embed && stream.next() == \"\\\\\";\n          } else {\n            stream.next();\n            escaped = false;\n          }\n        }\n\n        return \"string\";\n      };\n    }\n\n    return {\n      startState: function startState() {\n        return {\n          tokenize: [tokenBase],\n          currentIndent: 0,\n          lastToken: null,\n          lastStyle: null,\n          blocks: []\n        };\n      },\n      token: function token(stream, state) {\n        var style = state.tokenize[state.tokenize.length - 1](stream, state);\n        var token = stream.current();\n\n        if (style && style != \"comment\") {\n          state.lastToken = token;\n          state.lastStyle = style;\n        }\n\n        return style;\n      },\n      indent: function indent(state, textAfter) {\n        textAfter = textAfter.replace(/^\\s*(?:\\{%)?\\s*|\\s*(?:%\\})?\\s*$/g, \"\");\n\n        if (dedentKeywords.test(textAfter) || dedentPunctuals.test(textAfter)) {\n          return config.indentUnit * (state.currentIndent - 1);\n        }\n\n        return config.indentUnit * state.currentIndent;\n      },\n      fold: \"indent\",\n      electricInput: wordRegExp(dedentPunctualsArray.concat(dedentKeywordsArray), true),\n      lineComment: '#'\n    };\n  });\n  CodeMirror.defineMIME(\"text/x-crystal\", \"crystal\");\n});"],"sourceRoot":""}