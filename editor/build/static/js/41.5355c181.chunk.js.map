{"version":3,"sources":["../node_modules/codemirror/mode/haskell-literate/haskell-literate.js","../node_modules/codemirror/mode/haskell/haskell.js"],"names":["CodeMirror","defineMode","config","parserConfig","baseMode","getMode","base","startState","inCode","baseState","token","stream","state","sol","eat","skipToEnd","innerMode","mode","defineMIME","mod","__webpack_require__","_config","modeConfig","switchState","source","setState","f","smallRE","largeRE","digitRE","hexitRE","octitRE","idRE","symbolRE","specialRE","whiteCharRE","normal","eatWhile","ch","next","test","t","ncomment","type","nest","currNest","eol","stringLiteral","match","stringGap","wellKnownWords","wkw","setType","i","arguments","length","override","overrideKeywords","word","hasOwnProperty","copyState","s","w","current","blockCommentStart","blockCommentEnd","lineComment"],"mappings":"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","file":"static/js/41.5355c181.chunk.js","sourcesContent":["// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n(function (mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"), require(\"../haskell/haskell\"));else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\", \"../haskell/haskell\"], mod);else // Plain browser env\n    mod(CodeMirror);\n})(function (CodeMirror) {\n  \"use strict\";\n\n  CodeMirror.defineMode(\"haskell-literate\", function (config, parserConfig) {\n    var baseMode = CodeMirror.getMode(config, parserConfig && parserConfig.base || \"haskell\");\n    return {\n      startState: function startState() {\n        return {\n          inCode: false,\n          baseState: CodeMirror.startState(baseMode)\n        };\n      },\n      token: function token(stream, state) {\n        if (stream.sol()) {\n          if (state.inCode = stream.eat(\">\")) return \"meta\";\n        }\n\n        if (state.inCode) {\n          return baseMode.token(stream, state.baseState);\n        } else {\n          stream.skipToEnd();\n          return \"comment\";\n        }\n      },\n      innerMode: function innerMode(state) {\n        return state.inCode ? {\n          state: state.baseState,\n          mode: baseMode\n        } : null;\n      }\n    };\n  }, \"haskell\");\n  CodeMirror.defineMIME(\"text/x-literate-haskell\", \"haskell-literate\");\n});","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n(function (mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);else // Plain browser env\n    mod(CodeMirror);\n})(function (CodeMirror) {\n  \"use strict\";\n\n  CodeMirror.defineMode(\"haskell\", function (_config, modeConfig) {\n    function switchState(source, setState, f) {\n      setState(f);\n      return f(source, setState);\n    } // These should all be Unicode extended, as per the Haskell 2010 report\n\n\n    var smallRE = /[a-z_]/;\n    var largeRE = /[A-Z]/;\n    var digitRE = /\\d/;\n    var hexitRE = /[0-9A-Fa-f]/;\n    var octitRE = /[0-7]/;\n    var idRE = /[a-z_A-Z0-9'\\xa1-\\uffff]/;\n    var symbolRE = /[-!#$%&*+.\\/<=>?@\\\\^|~:]/;\n    var specialRE = /[(),;[\\]`{}]/;\n    var whiteCharRE = /[ \\t\\v\\f]/; // newlines are handled in tokenizer\n\n    function normal(source, setState) {\n      if (source.eatWhile(whiteCharRE)) {\n        return null;\n      }\n\n      var ch = source.next();\n\n      if (specialRE.test(ch)) {\n        if (ch == '{' && source.eat('-')) {\n          var t = \"comment\";\n\n          if (source.eat('#')) {\n            t = \"meta\";\n          }\n\n          return switchState(source, setState, ncomment(t, 1));\n        }\n\n        return null;\n      }\n\n      if (ch == '\\'') {\n        if (source.eat('\\\\')) {\n          source.next(); // should handle other escapes here\n        } else {\n          source.next();\n        }\n\n        if (source.eat('\\'')) {\n          return \"string\";\n        }\n\n        return \"string error\";\n      }\n\n      if (ch == '\"') {\n        return switchState(source, setState, stringLiteral);\n      }\n\n      if (largeRE.test(ch)) {\n        source.eatWhile(idRE);\n\n        if (source.eat('.')) {\n          return \"qualifier\";\n        }\n\n        return \"variable-2\";\n      }\n\n      if (smallRE.test(ch)) {\n        source.eatWhile(idRE);\n        return \"variable\";\n      }\n\n      if (digitRE.test(ch)) {\n        if (ch == '0') {\n          if (source.eat(/[xX]/)) {\n            source.eatWhile(hexitRE); // should require at least 1\n\n            return \"integer\";\n          }\n\n          if (source.eat(/[oO]/)) {\n            source.eatWhile(octitRE); // should require at least 1\n\n            return \"number\";\n          }\n        }\n\n        source.eatWhile(digitRE);\n        var t = \"number\";\n\n        if (source.match(/^\\.\\d+/)) {\n          t = \"number\";\n        }\n\n        if (source.eat(/[eE]/)) {\n          t = \"number\";\n          source.eat(/[-+]/);\n          source.eatWhile(digitRE); // should require at least 1\n        }\n\n        return t;\n      }\n\n      if (ch == \".\" && source.eat(\".\")) return \"keyword\";\n\n      if (symbolRE.test(ch)) {\n        if (ch == '-' && source.eat(/-/)) {\n          source.eatWhile(/-/);\n\n          if (!source.eat(symbolRE)) {\n            source.skipToEnd();\n            return \"comment\";\n          }\n        }\n\n        var t = \"variable\";\n\n        if (ch == ':') {\n          t = \"variable-2\";\n        }\n\n        source.eatWhile(symbolRE);\n        return t;\n      }\n\n      return \"error\";\n    }\n\n    function ncomment(type, nest) {\n      if (nest == 0) {\n        return normal;\n      }\n\n      return function (source, setState) {\n        var currNest = nest;\n\n        while (!source.eol()) {\n          var ch = source.next();\n\n          if (ch == '{' && source.eat('-')) {\n            ++currNest;\n          } else if (ch == '-' && source.eat('}')) {\n            --currNest;\n\n            if (currNest == 0) {\n              setState(normal);\n              return type;\n            }\n          }\n        }\n\n        setState(ncomment(type, currNest));\n        return type;\n      };\n    }\n\n    function stringLiteral(source, setState) {\n      while (!source.eol()) {\n        var ch = source.next();\n\n        if (ch == '\"') {\n          setState(normal);\n          return \"string\";\n        }\n\n        if (ch == '\\\\') {\n          if (source.eol() || source.eat(whiteCharRE)) {\n            setState(stringGap);\n            return \"string\";\n          }\n\n          if (source.eat('&')) {} else {\n            source.next(); // should handle other escapes here\n          }\n        }\n      }\n\n      setState(normal);\n      return \"string error\";\n    }\n\n    function stringGap(source, setState) {\n      if (source.eat('\\\\')) {\n        return switchState(source, setState, stringLiteral);\n      }\n\n      source.next();\n      setState(normal);\n      return \"error\";\n    }\n\n    var wellKnownWords = function () {\n      var wkw = {};\n\n      function setType(t) {\n        return function () {\n          for (var i = 0; i < arguments.length; i++) {\n            wkw[arguments[i]] = t;\n          }\n        };\n      }\n\n      setType(\"keyword\")(\"case\", \"class\", \"data\", \"default\", \"deriving\", \"do\", \"else\", \"foreign\", \"if\", \"import\", \"in\", \"infix\", \"infixl\", \"infixr\", \"instance\", \"let\", \"module\", \"newtype\", \"of\", \"then\", \"type\", \"where\", \"_\");\n      setType(\"keyword\")(\"\\.\\.\", \":\", \"::\", \"=\", \"\\\\\", \"<-\", \"->\", \"@\", \"~\", \"=>\");\n      setType(\"builtin\")(\"!!\", \"$!\", \"$\", \"&&\", \"+\", \"++\", \"-\", \".\", \"/\", \"/=\", \"<\", \"<*\", \"<=\", \"<$>\", \"<*>\", \"=<<\", \"==\", \">\", \">=\", \">>\", \">>=\", \"^\", \"^^\", \"||\", \"*\", \"*>\", \"**\");\n      setType(\"builtin\")(\"Applicative\", \"Bool\", \"Bounded\", \"Char\", \"Double\", \"EQ\", \"Either\", \"Enum\", \"Eq\", \"False\", \"FilePath\", \"Float\", \"Floating\", \"Fractional\", \"Functor\", \"GT\", \"IO\", \"IOError\", \"Int\", \"Integer\", \"Integral\", \"Just\", \"LT\", \"Left\", \"Maybe\", \"Monad\", \"Nothing\", \"Num\", \"Ord\", \"Ordering\", \"Rational\", \"Read\", \"ReadS\", \"Real\", \"RealFloat\", \"RealFrac\", \"Right\", \"Show\", \"ShowS\", \"String\", \"True\");\n      setType(\"builtin\")(\"abs\", \"acos\", \"acosh\", \"all\", \"and\", \"any\", \"appendFile\", \"asTypeOf\", \"asin\", \"asinh\", \"atan\", \"atan2\", \"atanh\", \"break\", \"catch\", \"ceiling\", \"compare\", \"concat\", \"concatMap\", \"const\", \"cos\", \"cosh\", \"curry\", \"cycle\", \"decodeFloat\", \"div\", \"divMod\", \"drop\", \"dropWhile\", \"either\", \"elem\", \"encodeFloat\", \"enumFrom\", \"enumFromThen\", \"enumFromThenTo\", \"enumFromTo\", \"error\", \"even\", \"exp\", \"exponent\", \"fail\", \"filter\", \"flip\", \"floatDigits\", \"floatRadix\", \"floatRange\", \"floor\", \"fmap\", \"foldl\", \"foldl1\", \"foldr\", \"foldr1\", \"fromEnum\", \"fromInteger\", \"fromIntegral\", \"fromRational\", \"fst\", \"gcd\", \"getChar\", \"getContents\", \"getLine\", \"head\", \"id\", \"init\", \"interact\", \"ioError\", \"isDenormalized\", \"isIEEE\", \"isInfinite\", \"isNaN\", \"isNegativeZero\", \"iterate\", \"last\", \"lcm\", \"length\", \"lex\", \"lines\", \"log\", \"logBase\", \"lookup\", \"map\", \"mapM\", \"mapM_\", \"max\", \"maxBound\", \"maximum\", \"maybe\", \"min\", \"minBound\", \"minimum\", \"mod\", \"negate\", \"not\", \"notElem\", \"null\", \"odd\", \"or\", \"otherwise\", \"pi\", \"pred\", \"print\", \"product\", \"properFraction\", \"pure\", \"putChar\", \"putStr\", \"putStrLn\", \"quot\", \"quotRem\", \"read\", \"readFile\", \"readIO\", \"readList\", \"readLn\", \"readParen\", \"reads\", \"readsPrec\", \"realToFrac\", \"recip\", \"rem\", \"repeat\", \"replicate\", \"return\", \"reverse\", \"round\", \"scaleFloat\", \"scanl\", \"scanl1\", \"scanr\", \"scanr1\", \"seq\", \"sequence\", \"sequence_\", \"show\", \"showChar\", \"showList\", \"showParen\", \"showString\", \"shows\", \"showsPrec\", \"significand\", \"signum\", \"sin\", \"sinh\", \"snd\", \"span\", \"splitAt\", \"sqrt\", \"subtract\", \"succ\", \"sum\", \"tail\", \"take\", \"takeWhile\", \"tan\", \"tanh\", \"toEnum\", \"toInteger\", \"toRational\", \"truncate\", \"uncurry\", \"undefined\", \"unlines\", \"until\", \"unwords\", \"unzip\", \"unzip3\", \"userError\", \"words\", \"writeFile\", \"zip\", \"zip3\", \"zipWith\", \"zipWith3\");\n      var override = modeConfig.overrideKeywords;\n      if (override) for (var word in override) {\n        if (override.hasOwnProperty(word)) wkw[word] = override[word];\n      }\n      return wkw;\n    }();\n\n    return {\n      startState: function startState() {\n        return {\n          f: normal\n        };\n      },\n      copyState: function copyState(s) {\n        return {\n          f: s.f\n        };\n      },\n      token: function token(stream, state) {\n        var t = state.f(stream, function (s) {\n          state.f = s;\n        });\n        var w = stream.current();\n        return wellKnownWords.hasOwnProperty(w) ? wellKnownWords[w] : t;\n      },\n      blockCommentStart: \"{-\",\n      blockCommentEnd: \"-}\",\n      lineComment: \"--\"\n    };\n  });\n  CodeMirror.defineMIME(\"text/x-haskell\", \"haskell\");\n});"],"sourceRoot":""}