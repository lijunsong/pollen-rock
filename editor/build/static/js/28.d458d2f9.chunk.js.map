{"version":3,"sources":["../node_modules/codemirror/mode/elm/elm.js"],"names":["CodeMirror","defineMode","switchState","source","setState","f","smallRE","largeRE","digitRE","hexitRE","octitRE","idRE","symbolRE","specialRE","whiteCharRE","normal","eatWhile","ch","next","test","eat","t","ncomment","type","nest","currNest","eol","stringLiteral","isDef","pos","skipToEnd","stringGap","wellKnownWords","wkw","keywords","i","length","startState","copyState","s","token","stream","state","w","current","hasOwnProperty","defineMIME","mod","__webpack_require__"],"mappings":"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","file":"static/js/28.d458d2f9.chunk.js","sourcesContent":["// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n(function (mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);else // Plain browser env\n    mod(CodeMirror);\n})(function (CodeMirror) {\n  \"use strict\";\n\n  CodeMirror.defineMode(\"elm\", function () {\n    function switchState(source, setState, f) {\n      setState(f);\n      return f(source, setState);\n    } // These should all be Unicode extended, as per the Haskell 2010 report\n\n\n    var smallRE = /[a-z_]/;\n    var largeRE = /[A-Z]/;\n    var digitRE = /[0-9]/;\n    var hexitRE = /[0-9A-Fa-f]/;\n    var octitRE = /[0-7]/;\n    var idRE = /[a-z_A-Z0-9\\']/;\n    var symbolRE = /[-!#$%&*+.\\/<=>?@\\\\^|~:\\u03BB\\u2192]/;\n    var specialRE = /[(),;[\\]`{}]/;\n    var whiteCharRE = /[ \\t\\v\\f]/; // newlines are handled in tokenizer\n\n    function normal() {\n      return function (source, setState) {\n        if (source.eatWhile(whiteCharRE)) {\n          return null;\n        }\n\n        var ch = source.next();\n\n        if (specialRE.test(ch)) {\n          if (ch == '{' && source.eat('-')) {\n            var t = \"comment\";\n            if (source.eat('#')) t = \"meta\";\n            return switchState(source, setState, ncomment(t, 1));\n          }\n\n          return null;\n        }\n\n        if (ch == '\\'') {\n          if (source.eat('\\\\')) source.next(); // should handle other escapes here\n          else source.next();\n          if (source.eat('\\'')) return \"string\";\n          return \"error\";\n        }\n\n        if (ch == '\"') {\n          return switchState(source, setState, stringLiteral);\n        }\n\n        if (largeRE.test(ch)) {\n          source.eatWhile(idRE);\n          if (source.eat('.')) return \"qualifier\";\n          return \"variable-2\";\n        }\n\n        if (smallRE.test(ch)) {\n          var isDef = source.pos === 1;\n          source.eatWhile(idRE);\n          return isDef ? \"type\" : \"variable\";\n        }\n\n        if (digitRE.test(ch)) {\n          if (ch == '0') {\n            if (source.eat(/[xX]/)) {\n              source.eatWhile(hexitRE); // should require at least 1\n\n              return \"integer\";\n            }\n\n            if (source.eat(/[oO]/)) {\n              source.eatWhile(octitRE); // should require at least 1\n\n              return \"number\";\n            }\n          }\n\n          source.eatWhile(digitRE);\n          var t = \"number\";\n\n          if (source.eat('.')) {\n            t = \"number\";\n            source.eatWhile(digitRE); // should require at least 1\n          }\n\n          if (source.eat(/[eE]/)) {\n            t = \"number\";\n            source.eat(/[-+]/);\n            source.eatWhile(digitRE); // should require at least 1\n          }\n\n          return t;\n        }\n\n        if (symbolRE.test(ch)) {\n          if (ch == '-' && source.eat(/-/)) {\n            source.eatWhile(/-/);\n\n            if (!source.eat(symbolRE)) {\n              source.skipToEnd();\n              return \"comment\";\n            }\n          }\n\n          source.eatWhile(symbolRE);\n          return \"builtin\";\n        }\n\n        return \"error\";\n      };\n    }\n\n    function ncomment(type, nest) {\n      if (nest == 0) {\n        return normal();\n      }\n\n      return function (source, setState) {\n        var currNest = nest;\n\n        while (!source.eol()) {\n          var ch = source.next();\n\n          if (ch == '{' && source.eat('-')) {\n            ++currNest;\n          } else if (ch == '-' && source.eat('}')) {\n            --currNest;\n\n            if (currNest == 0) {\n              setState(normal());\n              return type;\n            }\n          }\n        }\n\n        setState(ncomment(type, currNest));\n        return type;\n      };\n    }\n\n    function stringLiteral(source, setState) {\n      while (!source.eol()) {\n        var ch = source.next();\n\n        if (ch == '\"') {\n          setState(normal());\n          return \"string\";\n        }\n\n        if (ch == '\\\\') {\n          if (source.eol() || source.eat(whiteCharRE)) {\n            setState(stringGap);\n            return \"string\";\n          }\n\n          if (!source.eat('&')) source.next(); // should handle other escapes here\n        }\n      }\n\n      setState(normal());\n      return \"error\";\n    }\n\n    function stringGap(source, setState) {\n      if (source.eat('\\\\')) {\n        return switchState(source, setState, stringLiteral);\n      }\n\n      source.next();\n      setState(normal());\n      return \"error\";\n    }\n\n    var wellKnownWords = function () {\n      var wkw = {};\n      var keywords = [\"case\", \"of\", \"as\", \"if\", \"then\", \"else\", \"let\", \"in\", \"infix\", \"infixl\", \"infixr\", \"type\", \"alias\", \"input\", \"output\", \"foreign\", \"loopback\", \"module\", \"where\", \"import\", \"exposing\", \"_\", \"..\", \"|\", \":\", \"=\", \"\\\\\", \"\\\"\", \"->\", \"<-\"];\n\n      for (var i = keywords.length; i--;) {\n        wkw[keywords[i]] = \"keyword\";\n      }\n\n      return wkw;\n    }();\n\n    return {\n      startState: function startState() {\n        return {\n          f: normal()\n        };\n      },\n      copyState: function copyState(s) {\n        return {\n          f: s.f\n        };\n      },\n      token: function token(stream, state) {\n        var t = state.f(stream, function (s) {\n          state.f = s;\n        });\n        var w = stream.current();\n        return wellKnownWords.hasOwnProperty(w) ? wellKnownWords[w] : t;\n      }\n    };\n  });\n  CodeMirror.defineMIME(\"text/x-elm\", \"elm\");\n});"],"sourceRoot":""}