{"version":3,"sources":["../node_modules/codemirror/mode/q/q.js"],"names":["CodeMirror","defineMode","config","curPunc","indentUnit","keywords","RegExp","join","E","tokenBase","stream","state","sol","c","next","tokenize","tokenLineComment","eol","test","peek","skipToEnd","current","tokenCommentToEOF","tokenString","eatWhile","t","backUp","match","tokenBlockComment","f","escaped","end","pushContext","type","col","context","prev","indent","popContext","startState","token","align","indentation","style","column","textAfter","firstChar","charAt","closing","defineMIME","mod","__webpack_require__"],"mappings":"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","file":"static/js/72.390d1a62.chunk.js","sourcesContent":["// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n(function (mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);else // Plain browser env\n    mod(CodeMirror);\n})(function (CodeMirror) {\n  \"use strict\";\n\n  CodeMirror.defineMode(\"q\", function (config) {\n    var indentUnit = config.indentUnit,\n        curPunc,\n        keywords = buildRE([\"abs\", \"acos\", \"aj\", \"aj0\", \"all\", \"and\", \"any\", \"asc\", \"asin\", \"asof\", \"atan\", \"attr\", \"avg\", \"avgs\", \"bin\", \"by\", \"ceiling\", \"cols\", \"cor\", \"cos\", \"count\", \"cov\", \"cross\", \"csv\", \"cut\", \"delete\", \"deltas\", \"desc\", \"dev\", \"differ\", \"distinct\", \"div\", \"do\", \"each\", \"ej\", \"enlist\", \"eval\", \"except\", \"exec\", \"exit\", \"exp\", \"fby\", \"fills\", \"first\", \"fkeys\", \"flip\", \"floor\", \"from\", \"get\", \"getenv\", \"group\", \"gtime\", \"hclose\", \"hcount\", \"hdel\", \"hopen\", \"hsym\", \"iasc\", \"idesc\", \"if\", \"ij\", \"in\", \"insert\", \"inter\", \"inv\", \"key\", \"keys\", \"last\", \"like\", \"list\", \"lj\", \"load\", \"log\", \"lower\", \"lsq\", \"ltime\", \"ltrim\", \"mavg\", \"max\", \"maxs\", \"mcount\", \"md5\", \"mdev\", \"med\", \"meta\", \"min\", \"mins\", \"mmax\", \"mmin\", \"mmu\", \"mod\", \"msum\", \"neg\", \"next\", \"not\", \"null\", \"or\", \"over\", \"parse\", \"peach\", \"pj\", \"plist\", \"prd\", \"prds\", \"prev\", \"prior\", \"rand\", \"rank\", \"ratios\", \"raze\", \"read0\", \"read1\", \"reciprocal\", \"reverse\", \"rload\", \"rotate\", \"rsave\", \"rtrim\", \"save\", \"scan\", \"select\", \"set\", \"setenv\", \"show\", \"signum\", \"sin\", \"sqrt\", \"ss\", \"ssr\", \"string\", \"sublist\", \"sum\", \"sums\", \"sv\", \"system\", \"tables\", \"tan\", \"til\", \"trim\", \"txf\", \"type\", \"uj\", \"ungroup\", \"union\", \"update\", \"upper\", \"upsert\", \"value\", \"var\", \"view\", \"views\", \"vs\", \"wavg\", \"where\", \"where\", \"while\", \"within\", \"wj\", \"wj1\", \"wsum\", \"xasc\", \"xbar\", \"xcol\", \"xcols\", \"xdesc\", \"xexp\", \"xgroup\", \"xkey\", \"xlog\", \"xprev\", \"xrank\"]),\n        E = /[|/&^!+:\\\\\\-*%$=~#;@><,?_\\'\\\"\\[\\(\\]\\)\\s{}]/;\n\n    function buildRE(w) {\n      return new RegExp(\"^(\" + w.join(\"|\") + \")$\");\n    }\n\n    function tokenBase(stream, state) {\n      var sol = stream.sol(),\n          c = stream.next();\n      curPunc = null;\n      if (sol) if (c == \"/\") return (state.tokenize = tokenLineComment)(stream, state);else if (c == \"\\\\\") {\n        if (stream.eol() || /\\s/.test(stream.peek())) return stream.skipToEnd(), /^\\\\\\s*$/.test(stream.current()) ? (state.tokenize = tokenCommentToEOF)(stream) : state.tokenize = tokenBase, \"comment\";else return state.tokenize = tokenBase, \"builtin\";\n      }\n      if (/\\s/.test(c)) return stream.peek() == \"/\" ? (stream.skipToEnd(), \"comment\") : \"whitespace\";\n      if (c == '\"') return (state.tokenize = tokenString)(stream, state);\n      if (c == '`') return stream.eatWhile(/[A-Za-z\\d_:\\/.]/), \"symbol\";\n\n      if (\".\" == c && /\\d/.test(stream.peek()) || /\\d/.test(c)) {\n        var t = null;\n        stream.backUp(1);\n        if (stream.match(/^\\d{4}\\.\\d{2}(m|\\.\\d{2}([DT](\\d{2}(:\\d{2}(:\\d{2}(\\.\\d{1,9})?)?)?)?)?)/) || stream.match(/^\\d+D(\\d{2}(:\\d{2}(:\\d{2}(\\.\\d{1,9})?)?)?)/) || stream.match(/^\\d{2}:\\d{2}(:\\d{2}(\\.\\d{1,9})?)?/) || stream.match(/^\\d+[ptuv]{1}/)) t = \"temporal\";else if (stream.match(/^0[NwW]{1}/) || stream.match(/^0x[\\da-fA-F]*/) || stream.match(/^[01]+[b]{1}/) || stream.match(/^\\d+[chijn]{1}/) || stream.match(/-?\\d*(\\.\\d*)?(e[+\\-]?\\d+)?(e|f)?/)) t = \"number\";\n        return t && (!(c = stream.peek()) || E.test(c)) ? t : (stream.next(), \"error\");\n      }\n\n      if (/[A-Za-z]|\\./.test(c)) return stream.eatWhile(/[A-Za-z._\\d]/), keywords.test(stream.current()) ? \"keyword\" : \"variable\";\n      if (/[|/&^!+:\\\\\\-*%$=~#;@><\\.,?_\\']/.test(c)) return null;\n      if (/[{}\\(\\[\\]\\)]/.test(c)) return null;\n      return \"error\";\n    }\n\n    function tokenLineComment(stream, state) {\n      return stream.skipToEnd(), /\\/\\s*$/.test(stream.current()) ? (state.tokenize = tokenBlockComment)(stream, state) : state.tokenize = tokenBase, \"comment\";\n    }\n\n    function tokenBlockComment(stream, state) {\n      var f = stream.sol() && stream.peek() == \"\\\\\";\n      stream.skipToEnd();\n      if (f && /^\\\\\\s*$/.test(stream.current())) state.tokenize = tokenBase;\n      return \"comment\";\n    }\n\n    function tokenCommentToEOF(stream) {\n      return stream.skipToEnd(), \"comment\";\n    }\n\n    function tokenString(stream, state) {\n      var escaped = false,\n          next,\n          end = false;\n\n      while (next = stream.next()) {\n        if (next == \"\\\"\" && !escaped) {\n          end = true;\n          break;\n        }\n\n        escaped = !escaped && next == \"\\\\\";\n      }\n\n      if (end) state.tokenize = tokenBase;\n      return \"string\";\n    }\n\n    function pushContext(state, type, col) {\n      state.context = {\n        prev: state.context,\n        indent: state.indent,\n        col: col,\n        type: type\n      };\n    }\n\n    function popContext(state) {\n      state.indent = state.context.indent;\n      state.context = state.context.prev;\n    }\n\n    return {\n      startState: function startState() {\n        return {\n          tokenize: tokenBase,\n          context: null,\n          indent: 0,\n          col: 0\n        };\n      },\n      token: function token(stream, state) {\n        if (stream.sol()) {\n          if (state.context && state.context.align == null) state.context.align = false;\n          state.indent = stream.indentation();\n        } //if (stream.eatSpace()) return null;\n\n\n        var style = state.tokenize(stream, state);\n\n        if (style != \"comment\" && state.context && state.context.align == null && state.context.type != \"pattern\") {\n          state.context.align = true;\n        }\n\n        if (curPunc == \"(\") pushContext(state, \")\", stream.column());else if (curPunc == \"[\") pushContext(state, \"]\", stream.column());else if (curPunc == \"{\") pushContext(state, \"}\", stream.column());else if (/[\\]\\}\\)]/.test(curPunc)) {\n          while (state.context && state.context.type == \"pattern\") {\n            popContext(state);\n          }\n\n          if (state.context && curPunc == state.context.type) popContext(state);\n        } else if (curPunc == \".\" && state.context && state.context.type == \"pattern\") popContext(state);else if (/atom|string|variable/.test(style) && state.context) {\n          if (/[\\}\\]]/.test(state.context.type)) pushContext(state, \"pattern\", stream.column());else if (state.context.type == \"pattern\" && !state.context.align) {\n            state.context.align = true;\n            state.context.col = stream.column();\n          }\n        }\n        return style;\n      },\n      indent: function indent(state, textAfter) {\n        var firstChar = textAfter && textAfter.charAt(0);\n        var context = state.context;\n        if (/[\\]\\}]/.test(firstChar)) while (context && context.type == \"pattern\") {\n          context = context.prev;\n        }\n        var closing = context && firstChar == context.type;\n        if (!context) return 0;else if (context.type == \"pattern\") return context.col;else if (context.align) return context.col + (closing ? 0 : 1);else return context.indent + (closing ? 0 : indentUnit);\n      }\n    };\n  });\n  CodeMirror.defineMIME(\"text/x-q\", \"q\");\n});"],"sourceRoot":""}