{"version":3,"sources":["../node_modules/codemirror/mode/julia/julia.js"],"names":["CodeMirror","defineMode","config","parserConf","wordRegexp","words","end","RegExp","join","operators","delimiters","identifiers","chars","commonKeywords","commonBuiltins","registerHelper","concat","openers","closers","keywords","builtins","macro","symbol","stringPrefixes","inArray","state","inGenerator","bracket","depth","scope","currentScope","n","scopes","length","tokenBase","stream","match","tokenize","tokenComment","leavingExpr","sol","eatSpace","delimiter","ch","peek","skipToEnd","push","pop","lastToken","tokenAnnotation","imMatcher","numberLiteral","tokenChar","current","substr","eat","next","eatWhile","isDefinition","tokenCallOrDef","firstParenPos","charsAdvanced","backUp","nestedLevels","isChar","value","parseInt","external","startState","token","style","indent","textAfter","delta","indentUnit","electricInput","blockCommentStart","blockCommentEnd","lineComment","fold","defineMIME","mod","__webpack_require__"],"mappings":"+EAOC,SAAAA,GACD,aAEAA,EAAAC,WAAA,iBAAAC,EAAAC,GACA,SAAAC,EAAAC,EAAAC,GAKA,MAJA,qBAAAA,IACAA,EAAA,OAGA,IAAAC,OAAA,MAAAF,EAAAG,KAAA,YAAAF,GAGA,IAIAG,EAAAN,EAAAM,WAAAL,EAAA,2TACAM,EAAAP,EAAAO,YAAA,eACAC,EAAAR,EAAAQ,aAAA,wEACAC,EAAAR,EAAA,CAPA,iBACA,wBACA,2BACA,yEAIA,KAGAS,EAAA,8TACAC,EAAA,uCACAd,EAAAe,eAAA,oBAAAF,EAAAG,OAAAF,IACA,IAAAG,EAAAb,EALA,wIAMAc,EAAAd,EALA,2CAMAe,EAAAf,EAAAS,GACAO,EAAAhB,EAAAU,GACAO,EAAA,mBACAC,EAAA,+CACAC,EAAA,uCAEA,SAAAC,EAAAC,GACA,OAAAC,EAAAD,EAAA,KAGA,SAAAC,EAAAD,EAAAE,EAAAC,GACA,qBAAAD,IACAA,EAAA,KAGA,qBAAAC,IACAA,EAAA,GAGA,IAAAC,EAAAC,EAAAL,EAAAG,GAEA,YAAAA,GAAA,OAAAC,GAAAH,EAAAD,EAAAE,EAAAC,EAAA,YAAAC,GAAAH,EAAAD,EAAAE,EAAAC,EAAA,IAAAC,IAAAF,GAOA,SAAAG,EAAAL,EAAAM,GAKA,MAJA,qBAAAA,IACAA,EAAA,GAGAN,EAAAO,OAAAC,QAAAF,EACA,KAGAN,EAAAO,OAAAP,EAAAO,OAAAC,QAAAF,EAAA,IAIA,SAAAG,EAAAC,EAAAV,GAEA,GAAAU,EAAAC,MAAA,UAEA,OADAX,EAAAY,SAAAC,EACAb,EAAAY,SAAAF,EAAAV,GAIA,IAAAc,EAAAd,EAAAc,YAQA,GANAJ,EAAAK,QACAD,GAAA,GAGAd,EAAAc,aAAA,EAEAA,GACAJ,EAAAC,MAAA,OACA,iBAIA,GAAAD,EAAAC,MAAA,UACA,cACO,GAAAD,EAAAC,MAAA,WACP,iBAGA,GAAAD,EAAAM,WACA,YAGA,IAmDAL,EAsQAM,EAzTAC,EAAAR,EAAAS,OAEA,SAAAD,EAEA,OADAR,EAAAU,YACA,UAWA,GARA,MAAAF,GACAlB,EAAAO,OAAAc,KAAA,KAGA,MAAAH,GACAlB,EAAAO,OAAAc,KAAA,KAGAtB,EAAAC,IAAA,MAAAkB,EAAA,CAKA,IAJA,OAAAb,EAAAL,IACAA,EAAAO,OAAAe,MAGA,QAAAjB,EAAAL,IACAA,EAAAO,OAAAe,MAGAtB,EAAAO,OAAAe,MACAtB,EAAAc,aAAA,EAGA,GAAAb,EAAAD,IAAA,MAAAkB,EAAA,CAKA,IAJA,OAAAb,EAAAL,IACAA,EAAAO,OAAAe,MAGA,QAAAjB,EAAAL,IACAA,EAAAO,OAAAe,MAGAtB,EAAAO,OAAAe,MACAtB,EAAAc,aAAA,EAGA,GAAAf,EAAAC,GAAA,CACA,UAAAA,EAAAuB,WAAAb,EAAAC,MAAA,MACA,iBAGA,GAAAD,EAAAC,MAAA,QACA,eAMA,GAAAA,EAAAD,EAAAC,MAAAnB,GAEA,OADAQ,EAAAO,OAAAc,KAAAV,EAAA,IACA,UAGA,GAAAD,EAAAC,MAAAlB,GAEA,OADAO,EAAAO,OAAAe,MACA,UAIA,GAAAZ,EAAAC,MAAA,gBAEA,OADAX,EAAAY,SAAAY,EACAxB,EAAAY,SAAAF,EAAAV,GAIA,IAAAc,GAAAJ,EAAAC,MAAAd,IAAAa,EAAAC,MAAA,sEACA,gBAQA,GAAAD,EAAAC,MAAA3B,GACA,iBAIA,GAAA0B,EAAAC,MAAA,cACA,IAAAc,EAAA3C,OAAA,SACA4C,GAAA,EA4CA,GA1CAhB,EAAAC,MAAA,wCACAe,GAAA,GAGAhB,EAAAC,MAAA,qBACAe,GAAA,GAGAhB,EAAAC,MAAA,YACAe,GAAA,GAGAhB,EAAAC,MAAA,gCACAe,GAAA,GAIAhB,EAAAC,MAAA,mBACAe,GAAA,GAIAhB,EAAAC,MAAA,eACAe,GAAA,GAIAhB,EAAAC,MAAA,gBACAe,GAAA,GAIAhB,EAAAC,MAAA,6BACAe,GAAA,GAKAhB,EAAAC,MAAA,kBACAe,GAAA,GAGAA,EAIA,OAFAhB,EAAAC,MAAAc,GACAzB,EAAAc,aAAA,EACA,SAKA,GAAAJ,EAAAC,MAAA,MAEA,OADAX,EAAAY,SAAAe,EACA3B,EAAAY,SAAAF,EAAAV,GAIA,GAAAU,EAAAC,MAAAb,GAEA,OADAE,EAAAY,UAwKA,SADAK,EAvKAP,EAAAkB,WAwKAC,QAAA,GACAZ,EAAA,MACO,MAAAA,EAAAY,QAAA,KACPZ,EAAA,KAGA,SAAAP,EAAAV,GACA,GAAAU,EAAAoB,IAAA,MACApB,EAAAqB,WACS,IAAArB,EAAAC,MAAAM,GAGT,OAFAjB,EAAAY,SAAAH,EACAT,EAAAc,aAAA,EACA,SAEAJ,EAAAoB,IAAA,QAIA,OADApB,EAAAsB,SAAA,WACA,WAzLAhC,EAAAY,SAAAF,EAAAV,GAGA,GAAAU,EAAAC,MAAAf,GACA,aAGA,GAAAc,EAAAC,MAAA1B,GACA,YAGA,GAAAyB,EAAAC,MAAAjB,GACA,gBAGA,GAAAgB,EAAAC,MAAAhB,GACA,gBAGA,IAAAsC,EAAAjC,EAAAiC,cAAA,YAAAjC,EAAAuB,WAAA,SAAAvB,EAAAuB,WAAA,QAAAvB,EAAAuB,WAAA,UAAAvB,EAAAuB,WAAA,aAAAvB,EAAAuB,UAEA,OAAAb,EAAAC,MAAAzB,GACA+C,EACA,MAAAvB,EAAAS,QACAnB,EAAAiC,cAAA,EACA,aAGAjC,EAAAiC,cAAA,EACA,OAGAvB,EAAAC,MAAA,iBAAmC,IACnCX,EAAAY,SAAAsB,EACAlC,EAAAY,SAAAF,EAAAV,KAGAA,EAAAc,aAAA,EACA,aAIAJ,EAAAqB,OACA,SAGA,SAAAG,EAAAxB,EAAAV,GACA,IAAAW,EAAAD,EAAAC,MAAA,YAQA,GANAA,IACAX,EAAAmC,cAAA,IAAAnC,EAAAmC,cAAAnC,EAAAO,OAAAC,QACAR,EAAAO,OAAAc,KAAA,KACArB,EAAAoC,eAAAzB,EAAA,GAAAH,QAGA,KAAAH,EAAAL,IAAAU,EAAAC,MAAA,SACAX,EAAAO,OAAAe,MACAtB,EAAAoC,eAAA,EAEApC,EAAAO,OAAAC,QAAAR,EAAAmC,eAAA,CACA,IAAAF,EAAAvB,EAAAC,MAAA,uCAKA,OAJAD,EAAA2B,OAAArC,EAAAoC,eACApC,EAAAmC,eAAA,EACAnC,EAAAoC,cAAA,EACApC,EAAAY,SAAAH,EACAwB,EAAA,MACA,UAOA,GAAAvB,EAAAC,MAAA,WAGA,IAFAD,EAAA2B,OAAArC,EAAAoC,eAEApC,EAAAO,OAAAC,OAAAR,EAAAmC,eACAnC,EAAAO,OAAAe,MAMA,OAHAtB,EAAAmC,eAAA,EACAnC,EAAAoC,cAAA,EACApC,EAAAY,SAAAH,EACA,UAIA,OADAT,EAAAoC,eAAA1B,EAAAC,MAAA,gBAAAH,OACAR,EAAAY,SAAAF,EAAAV,GAGA,SAAAwB,EAAAd,EAAAV,GAeA,OAdAU,EAAAC,MAAA,+BAEAD,EAAAC,MAAA,MACAX,EAAAsC,eACO5B,EAAAC,MAAA,OACPX,EAAAsC,eAGAtC,EAAAsC,aAAA,EACA5B,EAAAC,MAAA,eAA+BD,EAAAqB,OACxB,GAAA/B,EAAAsC,eACPtC,EAAAY,SAAAH,GAGA,UAGA,SAAAI,EAAAH,EAAAV,GAcA,OAbAU,EAAAC,MAAA,QACAX,EAAAsC,eAGA5B,EAAAC,MAAA,mBACAD,EAAAU,YAGAV,EAAAC,MAAA,SACAX,EAAAsC,eACA,GAAAtC,EAAAsC,eAAAtC,EAAAY,SAAAH,IAGA,UAGA,SAAAkB,EAAAjB,EAAAV,GACA,IACAW,EADA4B,GAAA,EAGA,GAAA7B,EAAAC,MAAAxB,GACAoD,GAAA,OACO,GAAA5B,EAAAD,EAAAC,MAAA,4BAAiD,CACxD,IAAA6B,EAAAC,SAAA9B,EAAA,QAEA6B,GAAA,OAAAA,GAAA,SAEAD,GAAA,EACA7B,EAAAqB,aAEO,GAAApB,EAAAD,EAAAC,MAAA,8BAAoD,CAC3D,IAAA6B,EAAAC,SAAA9B,EAAA,OAEA6B,GAAA,UAEAD,GAAA,EACA7B,EAAAqB,QAIA,OAAAQ,GACAvC,EAAAc,aAAA,EACAd,EAAAY,SAAAH,EACA,WAGAC,EAAAC,MAAA,gBACAD,EAAAU,YAGAV,EAAAC,MAAA,QACAX,EAAAY,SAAAH,GAGA,SA4BA,IAAAiC,EAAA,CACAC,WAAA,WACA,OACA/B,SAAAH,EACAF,OAAA,GACAgB,UAAA,KACAT,aAAA,EACAmB,cAAA,EACAK,aAAA,EACAF,cAAA,EACAD,eAAA,IAGAS,MAAA,SAAAlC,EAAAV,GACA,IAAA6C,EAAA7C,EAAAY,SAAAF,EAAAV,GACA4B,EAAAlB,EAAAkB,UAMA,OAJAA,GAAAiB,IACA7C,EAAAuB,UAAAK,GAGAiB,GAEAC,OAAA,SAAA9C,EAAA+C,GACA,IAAAC,EAAA,EAMA,MAJA,MAAAD,GAAA,MAAAA,GAAA,QAAAA,GAAA,SAAAA,GAAA,UAAAA,GAAA,WAAAA,GAAA,YAAAA,IACAC,GAAA,IAGAhD,EAAAO,OAAAC,OAAAwC,GAAAvE,EAAAwE,YAEAC,cAAA,+BACAC,kBAAA,KACAC,gBAAA,KACAC,YAAA,IACAC,KAAA,UAEA,OAAAZ,IAEAnE,EAAAgF,WAAA,wBAjeAC,CAAQC,EAAQ","file":"static/js/49.05768ecb.chunk.js","sourcesContent":["// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n(function (mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);else // Plain browser env\n    mod(CodeMirror);\n})(function (CodeMirror) {\n  \"use strict\";\n\n  CodeMirror.defineMode(\"julia\", function (config, parserConf) {\n    function wordRegexp(words, end) {\n      if (typeof end === \"undefined\") {\n        end = \"\\\\b\";\n      }\n\n      return new RegExp(\"^((\" + words.join(\")|(\") + \"))\" + end);\n    }\n\n    var octChar = \"\\\\\\\\[0-7]{1,3}\";\n    var hexChar = \"\\\\\\\\x[A-Fa-f0-9]{1,2}\";\n    var sChar = \"\\\\\\\\[abefnrtv0%?'\\\"\\\\\\\\]\";\n    var uChar = \"([^\\\\u0027\\\\u005C\\\\uD800-\\\\uDFFF]|[\\\\uD800-\\\\uDFFF][\\\\uDC00-\\\\uDFFF])\";\n    var operators = parserConf.operators || wordRegexp([\"[<>]:\", \"[<>=]=\", \"<<=?\", \">>>?=?\", \"=>\", \"->\", \"\\\\/\\\\/\", \"[\\\\\\\\%*+\\\\-<>!=\\\\/^|&\\\\u00F7\\\\u22BB]=?\", \"\\\\?\", \"\\\\$\", \"~\", \":\", \"\\\\u00D7\", \"\\\\u2208\", \"\\\\u2209\", \"\\\\u220B\", \"\\\\u220C\", \"\\\\u2218\", \"\\\\u221A\", \"\\\\u221B\", \"\\\\u2229\", \"\\\\u222A\", \"\\\\u2260\", \"\\\\u2264\", \"\\\\u2265\", \"\\\\u2286\", \"\\\\u2288\", \"\\\\u228A\", \"\\\\u22C5\", \"\\\\b(in|isa)\\\\b(?!\\.?\\\\()\"], \"\");\n    var delimiters = parserConf.delimiters || /^[;,()[\\]{}]/;\n    var identifiers = parserConf.identifiers || /^[_A-Za-z\\u00A1-\\u2217\\u2219-\\uFFFF][\\w\\u00A1-\\u2217\\u2219-\\uFFFF]*!*/;\n    var chars = wordRegexp([octChar, hexChar, sChar, uChar], \"'\");\n    var commonOpeners = [\"begin\", \"function\", \"type\", \"struct\", \"immutable\", \"let\", \"macro\", \"for\", \"while\", \"quote\", \"if\", \"else\", \"elseif\", \"try\", \"finally\", \"catch\", \"do\"];\n    var commonClosers = [\"end\", \"else\", \"elseif\", \"catch\", \"finally\"];\n    var commonKeywords = [\"if\", \"else\", \"elseif\", \"while\", \"for\", \"begin\", \"let\", \"end\", \"do\", \"try\", \"catch\", \"finally\", \"return\", \"break\", \"continue\", \"global\", \"local\", \"const\", \"export\", \"import\", \"importall\", \"using\", \"function\", \"where\", \"macro\", \"module\", \"baremodule\", \"struct\", \"type\", \"mutable\", \"immutable\", \"quote\", \"typealias\", \"abstract\", \"primitive\", \"bitstype\"];\n    var commonBuiltins = [\"true\", \"false\", \"nothing\", \"NaN\", \"Inf\"];\n    CodeMirror.registerHelper(\"hintWords\", \"julia\", commonKeywords.concat(commonBuiltins));\n    var openers = wordRegexp(commonOpeners);\n    var closers = wordRegexp(commonClosers);\n    var keywords = wordRegexp(commonKeywords);\n    var builtins = wordRegexp(commonBuiltins);\n    var macro = /^@[_A-Za-z][\\w]*/;\n    var symbol = /^:[_A-Za-z\\u00A1-\\uFFFF][\\w\\u00A1-\\uFFFF]*!*/;\n    var stringPrefixes = /^(`|([_A-Za-z\\u00A1-\\uFFFF]*\"(\"\")?))/;\n\n    function inArray(state) {\n      return inGenerator(state, '[');\n    }\n\n    function inGenerator(state, bracket, depth) {\n      if (typeof bracket === \"undefined\") {\n        bracket = '(';\n      }\n\n      if (typeof depth === \"undefined\") {\n        depth = 0;\n      }\n\n      var scope = currentScope(state, depth);\n\n      if (depth == 0 && scope === \"if\" && inGenerator(state, bracket, depth + 1) || scope === \"for\" && inGenerator(state, bracket, depth + 1) || scope === bracket) {\n        return true;\n      }\n\n      return false;\n    }\n\n    function currentScope(state, n) {\n      if (typeof n === \"undefined\") {\n        n = 0;\n      }\n\n      if (state.scopes.length <= n) {\n        return null;\n      }\n\n      return state.scopes[state.scopes.length - (n + 1)];\n    } // tokenizers\n\n\n    function tokenBase(stream, state) {\n      // Handle multiline comments\n      if (stream.match(/^#=/, false)) {\n        state.tokenize = tokenComment;\n        return state.tokenize(stream, state);\n      } // Handle scope changes\n\n\n      var leavingExpr = state.leavingExpr;\n\n      if (stream.sol()) {\n        leavingExpr = false;\n      }\n\n      state.leavingExpr = false;\n\n      if (leavingExpr) {\n        if (stream.match(/^'+/)) {\n          return \"operator\";\n        }\n      }\n\n      if (stream.match(/\\.{4,}/)) {\n        return \"error\";\n      } else if (stream.match(/\\.{1,3}/)) {\n        return \"operator\";\n      }\n\n      if (stream.eatSpace()) {\n        return null;\n      }\n\n      var ch = stream.peek(); // Handle single line comments\n\n      if (ch === '#') {\n        stream.skipToEnd();\n        return \"comment\";\n      }\n\n      if (ch === '[') {\n        state.scopes.push('[');\n      }\n\n      if (ch === '(') {\n        state.scopes.push('(');\n      }\n\n      if (inArray(state) && ch === ']') {\n        if (currentScope(state) === \"if\") {\n          state.scopes.pop();\n        }\n\n        while (currentScope(state) === \"for\") {\n          state.scopes.pop();\n        }\n\n        state.scopes.pop();\n        state.leavingExpr = true;\n      }\n\n      if (inGenerator(state) && ch === ')') {\n        if (currentScope(state) === \"if\") {\n          state.scopes.pop();\n        }\n\n        while (currentScope(state) === \"for\") {\n          state.scopes.pop();\n        }\n\n        state.scopes.pop();\n        state.leavingExpr = true;\n      }\n\n      if (inArray(state)) {\n        if (state.lastToken == \"end\" && stream.match(/^:/)) {\n          return \"operator\";\n        }\n\n        if (stream.match(/^end/)) {\n          return \"number\";\n        }\n      }\n\n      var match;\n\n      if (match = stream.match(openers)) {\n        state.scopes.push(match[0]);\n        return \"keyword\";\n      }\n\n      if (stream.match(closers)) {\n        state.scopes.pop();\n        return \"keyword\";\n      } // Handle type annotations\n\n\n      if (stream.match(/^::(?![:\\$])/)) {\n        state.tokenize = tokenAnnotation;\n        return state.tokenize(stream, state);\n      } // Handle symbols\n\n\n      if (!leavingExpr && stream.match(symbol) || stream.match(/:([<>]:|<<=?|>>>?=?|->|\\/\\/|\\.{2,3}|[\\.\\\\%*+\\-<>!\\/^|&]=?|[~\\?\\$])/)) {\n        return \"builtin\";\n      } // Handle parametric types\n      //if (stream.match(/^{[^}]*}(?=\\()/)) {\n      //  return \"builtin\";\n      //}\n      // Handle operators and Delimiters\n\n\n      if (stream.match(operators)) {\n        return \"operator\";\n      } // Handle Number Literals\n\n\n      if (stream.match(/^\\.?\\d/, false)) {\n        var imMatcher = RegExp(/^im\\b/);\n        var numberLiteral = false; // Floats\n\n        if (stream.match(/^\\d*\\.(?!\\.)\\d*([Eef][\\+\\-]?\\d+)?/i)) {\n          numberLiteral = true;\n        }\n\n        if (stream.match(/^\\d+\\.(?!\\.)\\d*/)) {\n          numberLiteral = true;\n        }\n\n        if (stream.match(/^\\.\\d+/)) {\n          numberLiteral = true;\n        }\n\n        if (stream.match(/^0x\\.[0-9a-f]+p[\\+\\-]?\\d+/i)) {\n          numberLiteral = true;\n        } // Integers\n\n\n        if (stream.match(/^0x[0-9a-f]+/i)) {\n          numberLiteral = true;\n        } // Hex\n\n\n        if (stream.match(/^0b[01]+/i)) {\n          numberLiteral = true;\n        } // Binary\n\n\n        if (stream.match(/^0o[0-7]+/i)) {\n          numberLiteral = true;\n        } // Octal\n\n\n        if (stream.match(/^[1-9]\\d*(e[\\+\\-]?\\d+)?/)) {\n          numberLiteral = true;\n        } // Decimal\n        // Zero by itself with no other piece of number.\n\n\n        if (stream.match(/^0(?![\\dx])/i)) {\n          numberLiteral = true;\n        }\n\n        if (numberLiteral) {\n          // Integer literals may be \"long\"\n          stream.match(imMatcher);\n          state.leavingExpr = true;\n          return \"number\";\n        }\n      } // Handle Chars\n\n\n      if (stream.match(/^'/)) {\n        state.tokenize = tokenChar;\n        return state.tokenize(stream, state);\n      } // Handle Strings\n\n\n      if (stream.match(stringPrefixes)) {\n        state.tokenize = tokenStringFactory(stream.current());\n        return state.tokenize(stream, state);\n      }\n\n      if (stream.match(macro)) {\n        return \"meta\";\n      }\n\n      if (stream.match(delimiters)) {\n        return null;\n      }\n\n      if (stream.match(keywords)) {\n        return \"keyword\";\n      }\n\n      if (stream.match(builtins)) {\n        return \"builtin\";\n      }\n\n      var isDefinition = state.isDefinition || state.lastToken == \"function\" || state.lastToken == \"macro\" || state.lastToken == \"type\" || state.lastToken == \"struct\" || state.lastToken == \"immutable\";\n\n      if (stream.match(identifiers)) {\n        if (isDefinition) {\n          if (stream.peek() === '.') {\n            state.isDefinition = true;\n            return \"variable\";\n          }\n\n          state.isDefinition = false;\n          return \"def\";\n        }\n\n        if (stream.match(/^({[^}]*})*\\(/, false)) {\n          state.tokenize = tokenCallOrDef;\n          return state.tokenize(stream, state);\n        }\n\n        state.leavingExpr = true;\n        return \"variable\";\n      } // Handle non-detected items\n\n\n      stream.next();\n      return \"error\";\n    }\n\n    function tokenCallOrDef(stream, state) {\n      var match = stream.match(/^(\\(\\s*)/);\n\n      if (match) {\n        if (state.firstParenPos < 0) state.firstParenPos = state.scopes.length;\n        state.scopes.push('(');\n        state.charsAdvanced += match[1].length;\n      }\n\n      if (currentScope(state) == '(' && stream.match(/^\\)/)) {\n        state.scopes.pop();\n        state.charsAdvanced += 1;\n\n        if (state.scopes.length <= state.firstParenPos) {\n          var isDefinition = stream.match(/^(\\s*where\\s+[^\\s=]+)*\\s*?=(?!=)/, false);\n          stream.backUp(state.charsAdvanced);\n          state.firstParenPos = -1;\n          state.charsAdvanced = 0;\n          state.tokenize = tokenBase;\n          if (isDefinition) return \"def\";\n          return \"builtin\";\n        }\n      } // Unfortunately javascript does not support multiline strings, so we have\n      // to undo anything done upto here if a function call or definition splits\n      // over two or more lines.\n\n\n      if (stream.match(/^$/g, false)) {\n        stream.backUp(state.charsAdvanced);\n\n        while (state.scopes.length > state.firstParenPos) {\n          state.scopes.pop();\n        }\n\n        state.firstParenPos = -1;\n        state.charsAdvanced = 0;\n        state.tokenize = tokenBase;\n        return \"builtin\";\n      }\n\n      state.charsAdvanced += stream.match(/^([^()]*)/)[1].length;\n      return state.tokenize(stream, state);\n    }\n\n    function tokenAnnotation(stream, state) {\n      stream.match(/.*?(?=,|;|{|}|\\(|\\)|=|$|\\s)/);\n\n      if (stream.match(/^{/)) {\n        state.nestedLevels++;\n      } else if (stream.match(/^}/)) {\n        state.nestedLevels--;\n      }\n\n      if (state.nestedLevels > 0) {\n        stream.match(/.*?(?={|})/) || stream.next();\n      } else if (state.nestedLevels == 0) {\n        state.tokenize = tokenBase;\n      }\n\n      return \"builtin\";\n    }\n\n    function tokenComment(stream, state) {\n      if (stream.match(/^#=/)) {\n        state.nestedLevels++;\n      }\n\n      if (!stream.match(/.*?(?=(#=|=#))/)) {\n        stream.skipToEnd();\n      }\n\n      if (stream.match(/^=#/)) {\n        state.nestedLevels--;\n        if (state.nestedLevels == 0) state.tokenize = tokenBase;\n      }\n\n      return \"comment\";\n    }\n\n    function tokenChar(stream, state) {\n      var isChar = false,\n          match;\n\n      if (stream.match(chars)) {\n        isChar = true;\n      } else if (match = stream.match(/\\\\u([a-f0-9]{1,4})(?=')/i)) {\n        var value = parseInt(match[1], 16);\n\n        if (value <= 55295 || value >= 57344) {\n          // (U+0,U+D7FF), (U+E000,U+FFFF)\n          isChar = true;\n          stream.next();\n        }\n      } else if (match = stream.match(/\\\\U([A-Fa-f0-9]{5,8})(?=')/)) {\n        var value = parseInt(match[1], 16);\n\n        if (value <= 1114111) {\n          // U+10FFFF\n          isChar = true;\n          stream.next();\n        }\n      }\n\n      if (isChar) {\n        state.leavingExpr = true;\n        state.tokenize = tokenBase;\n        return \"string\";\n      }\n\n      if (!stream.match(/^[^']+(?=')/)) {\n        stream.skipToEnd();\n      }\n\n      if (stream.match(/^'/)) {\n        state.tokenize = tokenBase;\n      }\n\n      return \"error\";\n    }\n\n    function tokenStringFactory(delimiter) {\n      if (delimiter.substr(-3) === '\"\"\"') {\n        delimiter = '\"\"\"';\n      } else if (delimiter.substr(-1) === '\"') {\n        delimiter = '\"';\n      }\n\n      function tokenString(stream, state) {\n        if (stream.eat('\\\\')) {\n          stream.next();\n        } else if (stream.match(delimiter)) {\n          state.tokenize = tokenBase;\n          state.leavingExpr = true;\n          return \"string\";\n        } else {\n          stream.eat(/[`\"]/);\n        }\n\n        stream.eatWhile(/[^\\\\`\"]/);\n        return \"string\";\n      }\n\n      return tokenString;\n    }\n\n    var external = {\n      startState: function startState() {\n        return {\n          tokenize: tokenBase,\n          scopes: [],\n          lastToken: null,\n          leavingExpr: false,\n          isDefinition: false,\n          nestedLevels: 0,\n          charsAdvanced: 0,\n          firstParenPos: -1\n        };\n      },\n      token: function token(stream, state) {\n        var style = state.tokenize(stream, state);\n        var current = stream.current();\n\n        if (current && style) {\n          state.lastToken = current;\n        }\n\n        return style;\n      },\n      indent: function indent(state, textAfter) {\n        var delta = 0;\n\n        if (textAfter === ']' || textAfter === ')' || textAfter === \"end\" || textAfter === \"else\" || textAfter === \"catch\" || textAfter === \"elseif\" || textAfter === \"finally\") {\n          delta = -1;\n        }\n\n        return (state.scopes.length + delta) * config.indentUnit;\n      },\n      electricInput: /\\b(end|else|catch|finally)\\b/,\n      blockCommentStart: \"#=\",\n      blockCommentEnd: \"=#\",\n      lineComment: \"#\",\n      fold: \"indent\"\n    };\n    return external;\n  });\n  CodeMirror.defineMIME(\"text/x-julia\", \"julia\");\n});"],"sourceRoot":""}