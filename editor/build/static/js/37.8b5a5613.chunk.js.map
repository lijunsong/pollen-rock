{"version":3,"sources":["../node_modules/codemirror/mode/go/go.js"],"names":["CodeMirror","defineMode","config","curPunc","indentUnit","keywords","break","case","chan","const","continue","default","defer","else","fallthrough","for","func","go","goto","if","import","interface","map","package","range","return","select","struct","switch","type","var","bool","byte","complex64","complex128","float32","float64","int8","int16","int32","int64","string","uint8","uint16","uint32","uint64","int","uint","uintptr","error","rune","atoms","true","false","iota","nil","append","cap","close","complex","copy","delete","imag","len","make","new","panic","print","println","real","recover","isOperatorChar","tokenBase","stream","state","quote","ch","next","tokenize","escaped","end","test","match","eat","tokenComment","skipToEnd","eatWhile","cur","current","propertyIsEnumerable","maybeEnd","Context","indented","column","align","prev","this","pushContext","col","context","popContext","t","startState","basecolumn","startOfLine","token","ctx","sol","indentation","eatSpace","style","indent","textAfter","Pass","firstChar","charAt","closing","electricChars","closeBrackets","fold","blockCommentStart","blockCommentEnd","lineComment","defineMIME","mod","__webpack_require__"],"mappings":"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","file":"static/js/37.8b5a5613.chunk.js","sourcesContent":["// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n(function (mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);else // Plain browser env\n    mod(CodeMirror);\n})(function (CodeMirror) {\n  \"use strict\";\n\n  CodeMirror.defineMode(\"go\", function (config) {\n    var indentUnit = config.indentUnit;\n    var keywords = {\n      \"break\": true,\n      \"case\": true,\n      \"chan\": true,\n      \"const\": true,\n      \"continue\": true,\n      \"default\": true,\n      \"defer\": true,\n      \"else\": true,\n      \"fallthrough\": true,\n      \"for\": true,\n      \"func\": true,\n      \"go\": true,\n      \"goto\": true,\n      \"if\": true,\n      \"import\": true,\n      \"interface\": true,\n      \"map\": true,\n      \"package\": true,\n      \"range\": true,\n      \"return\": true,\n      \"select\": true,\n      \"struct\": true,\n      \"switch\": true,\n      \"type\": true,\n      \"var\": true,\n      \"bool\": true,\n      \"byte\": true,\n      \"complex64\": true,\n      \"complex128\": true,\n      \"float32\": true,\n      \"float64\": true,\n      \"int8\": true,\n      \"int16\": true,\n      \"int32\": true,\n      \"int64\": true,\n      \"string\": true,\n      \"uint8\": true,\n      \"uint16\": true,\n      \"uint32\": true,\n      \"uint64\": true,\n      \"int\": true,\n      \"uint\": true,\n      \"uintptr\": true,\n      \"error\": true,\n      \"rune\": true\n    };\n    var atoms = {\n      \"true\": true,\n      \"false\": true,\n      \"iota\": true,\n      \"nil\": true,\n      \"append\": true,\n      \"cap\": true,\n      \"close\": true,\n      \"complex\": true,\n      \"copy\": true,\n      \"delete\": true,\n      \"imag\": true,\n      \"len\": true,\n      \"make\": true,\n      \"new\": true,\n      \"panic\": true,\n      \"print\": true,\n      \"println\": true,\n      \"real\": true,\n      \"recover\": true\n    };\n    var isOperatorChar = /[+\\-*&^%:=<>!|\\/]/;\n    var curPunc;\n\n    function tokenBase(stream, state) {\n      var ch = stream.next();\n\n      if (ch == '\"' || ch == \"'\" || ch == \"`\") {\n        state.tokenize = tokenString(ch);\n        return state.tokenize(stream, state);\n      }\n\n      if (/[\\d\\.]/.test(ch)) {\n        if (ch == \".\") {\n          stream.match(/^[0-9]+([eE][\\-+]?[0-9]+)?/);\n        } else if (ch == \"0\") {\n          stream.match(/^[xX][0-9a-fA-F]+/) || stream.match(/^0[0-7]+/);\n        } else {\n          stream.match(/^[0-9]*\\.?[0-9]*([eE][\\-+]?[0-9]+)?/);\n        }\n\n        return \"number\";\n      }\n\n      if (/[\\[\\]{}\\(\\),;\\:\\.]/.test(ch)) {\n        curPunc = ch;\n        return null;\n      }\n\n      if (ch == \"/\") {\n        if (stream.eat(\"*\")) {\n          state.tokenize = tokenComment;\n          return tokenComment(stream, state);\n        }\n\n        if (stream.eat(\"/\")) {\n          stream.skipToEnd();\n          return \"comment\";\n        }\n      }\n\n      if (isOperatorChar.test(ch)) {\n        stream.eatWhile(isOperatorChar);\n        return \"operator\";\n      }\n\n      stream.eatWhile(/[\\w\\$_\\xa1-\\uffff]/);\n      var cur = stream.current();\n\n      if (keywords.propertyIsEnumerable(cur)) {\n        if (cur == \"case\" || cur == \"default\") curPunc = \"case\";\n        return \"keyword\";\n      }\n\n      if (atoms.propertyIsEnumerable(cur)) return \"atom\";\n      return \"variable\";\n    }\n\n    function tokenString(quote) {\n      return function (stream, state) {\n        var escaped = false,\n            next,\n            end = false;\n\n        while ((next = stream.next()) != null) {\n          if (next == quote && !escaped) {\n            end = true;\n            break;\n          }\n\n          escaped = !escaped && quote != \"`\" && next == \"\\\\\";\n        }\n\n        if (end || !(escaped || quote == \"`\")) state.tokenize = tokenBase;\n        return \"string\";\n      };\n    }\n\n    function tokenComment(stream, state) {\n      var maybeEnd = false,\n          ch;\n\n      while (ch = stream.next()) {\n        if (ch == \"/\" && maybeEnd) {\n          state.tokenize = tokenBase;\n          break;\n        }\n\n        maybeEnd = ch == \"*\";\n      }\n\n      return \"comment\";\n    }\n\n    function Context(indented, column, type, align, prev) {\n      this.indented = indented;\n      this.column = column;\n      this.type = type;\n      this.align = align;\n      this.prev = prev;\n    }\n\n    function pushContext(state, col, type) {\n      return state.context = new Context(state.indented, col, type, null, state.context);\n    }\n\n    function popContext(state) {\n      if (!state.context.prev) return;\n      var t = state.context.type;\n      if (t == \")\" || t == \"]\" || t == \"}\") state.indented = state.context.indented;\n      return state.context = state.context.prev;\n    } // Interface\n\n\n    return {\n      startState: function startState(basecolumn) {\n        return {\n          tokenize: null,\n          context: new Context((basecolumn || 0) - indentUnit, 0, \"top\", false),\n          indented: 0,\n          startOfLine: true\n        };\n      },\n      token: function token(stream, state) {\n        var ctx = state.context;\n\n        if (stream.sol()) {\n          if (ctx.align == null) ctx.align = false;\n          state.indented = stream.indentation();\n          state.startOfLine = true;\n          if (ctx.type == \"case\") ctx.type = \"}\";\n        }\n\n        if (stream.eatSpace()) return null;\n        curPunc = null;\n        var style = (state.tokenize || tokenBase)(stream, state);\n        if (style == \"comment\") return style;\n        if (ctx.align == null) ctx.align = true;\n        if (curPunc == \"{\") pushContext(state, stream.column(), \"}\");else if (curPunc == \"[\") pushContext(state, stream.column(), \"]\");else if (curPunc == \"(\") pushContext(state, stream.column(), \")\");else if (curPunc == \"case\") ctx.type = \"case\";else if (curPunc == \"}\" && ctx.type == \"}\") popContext(state);else if (curPunc == ctx.type) popContext(state);\n        state.startOfLine = false;\n        return style;\n      },\n      indent: function indent(state, textAfter) {\n        if (state.tokenize != tokenBase && state.tokenize != null) return CodeMirror.Pass;\n        var ctx = state.context,\n            firstChar = textAfter && textAfter.charAt(0);\n\n        if (ctx.type == \"case\" && /^(?:case|default)\\b/.test(textAfter)) {\n          state.context.type = \"}\";\n          return ctx.indented;\n        }\n\n        var closing = firstChar == ctx.type;\n        if (ctx.align) return ctx.column + (closing ? 0 : 1);else return ctx.indented + (closing ? 0 : indentUnit);\n      },\n      electricChars: \"{}):\",\n      closeBrackets: \"()[]{}''\\\"\\\"``\",\n      fold: \"brace\",\n      blockCommentStart: \"/*\",\n      blockCommentEnd: \"*/\",\n      lineComment: \"//\"\n    };\n  });\n  CodeMirror.defineMIME(\"text/x-go\", \"go\");\n});"],"sourceRoot":""}