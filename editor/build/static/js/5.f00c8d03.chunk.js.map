{"version":3,"sources":["../node_modules/codemirror/mode/pug/pug.js","../node_modules/codemirror/mode/xml/xml.js","../node_modules/codemirror/mode/htmlmixed/htmlmixed.js"],"names":["CodeMirror","defineMode","config","KEYWORD","DOCTYPE","ID","CLASS","ATTRS_NEST","{","(","[","jsMode","getMode","State","this","javaScriptLine","javaScriptLineExcludesColon","javaScriptArguments","javaScriptArgumentsDepth","isInterpolating","interpolationNesting","jsState","startState","restOfLine","isIncludeFiltered","isEach","lastTag","scriptType","isAttrs","attrsNest","inAttributeName","attributeIsType","attrValue","indentOf","Infinity","indentToken","innerMode","innerState","innerModeForLine","interpolation","stream","state","match","filter","innerModes","current","substring","setInnerMode","mode","mimeModes","indentation","name","force","sol","hideFirstChars","token","skipToEnd","prototype","copy","res","copyState","slice","tok","peek","next","interpolationContinued","includeFilteredContinued","eol","eachContinued","attrsContinued","push","length","pop","eat","trim","toLowerCase","toString","Function","replace","backUp","ex","javaScript","mixinCallAfter","callArguments","yieldStatement","doctype","caseStatement","when","defaultStatement","extendsStatement","append","prepend","block","include","includeFiltered","mixin","call","conditional","each","whileStatement","captures","tag","code","id","className","attrs","attributesBlock","eatSpace","indent","text","comment","colon","indexOf","dot","fail","defineMIME","mod","__webpack_require__","htmlConfig","autoSelfClosers","area","base","br","col","command","embed","frame","hr","img","input","keygen","link","meta","param","source","track","wbr","menuitem","implicitlyClosed","dd","li","optgroup","option","p","rp","rt","tbody","td","tfoot","th","tr","contextGrabbers","dt","address","article","aside","blockquote","dir","div","dl","fieldset","footer","form","h1","h2","h3","h4","h5","h6","header","hgroup","menu","nav","ol","pre","section","table","ul","thead","doNotIndent","allowUnquoted","allowMissing","caseFold","xmlConfig","allowMissingTagName","editorConf","config_","type","setStyle","indentUnit","defaults","htmlMode","prop","inText","chain","parser","tokenize","ch","inBlock","eatWhile","depth","inTag","baseState","tagName","tagStart","test","quote","closure","isInAttribute","inAttribute","stringStartCol","column","style","terminator","Context","startOfLine","prev","context","indented","hasOwnProperty","noIndent","popContext","maybePopContext","nextTagName","parentTagName","tagNameState","closeTagNameState","attrState","matchClosing","closeState","closeStateErr","_stream","attrEqState","attrValueState","attrContinuedState","isInText","baseIndent","textAfter","fullLine","Pass","multilineTagIndentPastTag","multilineTagIndentFactor","alignCDATA","tagAfter","exec","grabbers","electricInput","blockCommentStart","blockCommentEnd","configuration","helperType","skipAttribute","defaultTags","script","attrRegexpCache","getAttrValue","attr","regexp","RegExp","getAttrRegexp","getTagRegexp","anchored","addTags","from","to","dest","i","unshift","parserConfig","tags","configTags","configScript","scriptTypes","matches","html","htmlState","modeSpec","tagInfo","tagText","spec","findMatchingMode","endTagA","endTag","localState","localMode","pat","cur","close","search","maybeBackup","local","line"],"mappings":"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","file":"static/js/5.f00c8d03.chunk.js","sourcesContent":["// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n(function (mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"), require(\"../javascript/javascript\"), require(\"../css/css\"), require(\"../htmlmixed/htmlmixed\"));else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\", \"../javascript/javascript\", \"../css/css\", \"../htmlmixed/htmlmixed\"], mod);else // Plain browser env\n    mod(CodeMirror);\n})(function (CodeMirror) {\n  \"use strict\";\n\n  CodeMirror.defineMode(\"pug\", function (config) {\n    // token types\n    var KEYWORD = 'keyword';\n    var DOCTYPE = 'meta';\n    var ID = 'builtin';\n    var CLASS = 'qualifier';\n    var ATTRS_NEST = {\n      '{': '}',\n      '(': ')',\n      '[': ']'\n    };\n    var jsMode = CodeMirror.getMode(config, 'javascript');\n\n    function State() {\n      this.javaScriptLine = false;\n      this.javaScriptLineExcludesColon = false;\n      this.javaScriptArguments = false;\n      this.javaScriptArgumentsDepth = 0;\n      this.isInterpolating = false;\n      this.interpolationNesting = 0;\n      this.jsState = CodeMirror.startState(jsMode);\n      this.restOfLine = '';\n      this.isIncludeFiltered = false;\n      this.isEach = false;\n      this.lastTag = '';\n      this.scriptType = ''; // Attributes Mode\n\n      this.isAttrs = false;\n      this.attrsNest = [];\n      this.inAttributeName = true;\n      this.attributeIsType = false;\n      this.attrValue = ''; // Indented Mode\n\n      this.indentOf = Infinity;\n      this.indentToken = '';\n      this.innerMode = null;\n      this.innerState = null;\n      this.innerModeForLine = false;\n    }\n    /**\n     * Safely copy a state\n     *\n     * @return {State}\n     */\n\n\n    State.prototype.copy = function () {\n      var res = new State();\n      res.javaScriptLine = this.javaScriptLine;\n      res.javaScriptLineExcludesColon = this.javaScriptLineExcludesColon;\n      res.javaScriptArguments = this.javaScriptArguments;\n      res.javaScriptArgumentsDepth = this.javaScriptArgumentsDepth;\n      res.isInterpolating = this.isInterpolating;\n      res.interpolationNesting = this.interpolationNesting;\n      res.jsState = CodeMirror.copyState(jsMode, this.jsState);\n      res.innerMode = this.innerMode;\n\n      if (this.innerMode && this.innerState) {\n        res.innerState = CodeMirror.copyState(this.innerMode, this.innerState);\n      }\n\n      res.restOfLine = this.restOfLine;\n      res.isIncludeFiltered = this.isIncludeFiltered;\n      res.isEach = this.isEach;\n      res.lastTag = this.lastTag;\n      res.scriptType = this.scriptType;\n      res.isAttrs = this.isAttrs;\n      res.attrsNest = this.attrsNest.slice();\n      res.inAttributeName = this.inAttributeName;\n      res.attributeIsType = this.attributeIsType;\n      res.attrValue = this.attrValue;\n      res.indentOf = this.indentOf;\n      res.indentToken = this.indentToken;\n      res.innerModeForLine = this.innerModeForLine;\n      return res;\n    };\n\n    function javaScript(stream, state) {\n      if (stream.sol()) {\n        // if javaScriptLine was set at end of line, ignore it\n        state.javaScriptLine = false;\n        state.javaScriptLineExcludesColon = false;\n      }\n\n      if (state.javaScriptLine) {\n        if (state.javaScriptLineExcludesColon && stream.peek() === ':') {\n          state.javaScriptLine = false;\n          state.javaScriptLineExcludesColon = false;\n          return;\n        }\n\n        var tok = jsMode.token(stream, state.jsState);\n        if (stream.eol()) state.javaScriptLine = false;\n        return tok || true;\n      }\n    }\n\n    function javaScriptArguments(stream, state) {\n      if (state.javaScriptArguments) {\n        if (state.javaScriptArgumentsDepth === 0 && stream.peek() !== '(') {\n          state.javaScriptArguments = false;\n          return;\n        }\n\n        if (stream.peek() === '(') {\n          state.javaScriptArgumentsDepth++;\n        } else if (stream.peek() === ')') {\n          state.javaScriptArgumentsDepth--;\n        }\n\n        if (state.javaScriptArgumentsDepth === 0) {\n          state.javaScriptArguments = false;\n          return;\n        }\n\n        var tok = jsMode.token(stream, state.jsState);\n        return tok || true;\n      }\n    }\n\n    function yieldStatement(stream) {\n      if (stream.match(/^yield\\b/)) {\n        return 'keyword';\n      }\n    }\n\n    function doctype(stream) {\n      if (stream.match(/^(?:doctype) *([^\\n]+)?/)) {\n        return DOCTYPE;\n      }\n    }\n\n    function interpolation(stream, state) {\n      if (stream.match('#{')) {\n        state.isInterpolating = true;\n        state.interpolationNesting = 0;\n        return 'punctuation';\n      }\n    }\n\n    function interpolationContinued(stream, state) {\n      if (state.isInterpolating) {\n        if (stream.peek() === '}') {\n          state.interpolationNesting--;\n\n          if (state.interpolationNesting < 0) {\n            stream.next();\n            state.isInterpolating = false;\n            return 'punctuation';\n          }\n        } else if (stream.peek() === '{') {\n          state.interpolationNesting++;\n        }\n\n        return jsMode.token(stream, state.jsState) || true;\n      }\n    }\n\n    function caseStatement(stream, state) {\n      if (stream.match(/^case\\b/)) {\n        state.javaScriptLine = true;\n        return KEYWORD;\n      }\n    }\n\n    function when(stream, state) {\n      if (stream.match(/^when\\b/)) {\n        state.javaScriptLine = true;\n        state.javaScriptLineExcludesColon = true;\n        return KEYWORD;\n      }\n    }\n\n    function defaultStatement(stream) {\n      if (stream.match(/^default\\b/)) {\n        return KEYWORD;\n      }\n    }\n\n    function extendsStatement(stream, state) {\n      if (stream.match(/^extends?\\b/)) {\n        state.restOfLine = 'string';\n        return KEYWORD;\n      }\n    }\n\n    function append(stream, state) {\n      if (stream.match(/^append\\b/)) {\n        state.restOfLine = 'variable';\n        return KEYWORD;\n      }\n    }\n\n    function prepend(stream, state) {\n      if (stream.match(/^prepend\\b/)) {\n        state.restOfLine = 'variable';\n        return KEYWORD;\n      }\n    }\n\n    function block(stream, state) {\n      if (stream.match(/^block\\b *(?:(prepend|append)\\b)?/)) {\n        state.restOfLine = 'variable';\n        return KEYWORD;\n      }\n    }\n\n    function include(stream, state) {\n      if (stream.match(/^include\\b/)) {\n        state.restOfLine = 'string';\n        return KEYWORD;\n      }\n    }\n\n    function includeFiltered(stream, state) {\n      if (stream.match(/^include:([a-zA-Z0-9\\-]+)/, false) && stream.match('include')) {\n        state.isIncludeFiltered = true;\n        return KEYWORD;\n      }\n    }\n\n    function includeFilteredContinued(stream, state) {\n      if (state.isIncludeFiltered) {\n        var tok = filter(stream, state);\n        state.isIncludeFiltered = false;\n        state.restOfLine = 'string';\n        return tok;\n      }\n    }\n\n    function mixin(stream, state) {\n      if (stream.match(/^mixin\\b/)) {\n        state.javaScriptLine = true;\n        return KEYWORD;\n      }\n    }\n\n    function call(stream, state) {\n      if (stream.match(/^\\+([-\\w]+)/)) {\n        if (!stream.match(/^\\( *[-\\w]+ *=/, false)) {\n          state.javaScriptArguments = true;\n          state.javaScriptArgumentsDepth = 0;\n        }\n\n        return 'variable';\n      }\n\n      if (stream.match(/^\\+#{/, false)) {\n        stream.next();\n        state.mixinCallAfter = true;\n        return interpolation(stream, state);\n      }\n    }\n\n    function callArguments(stream, state) {\n      if (state.mixinCallAfter) {\n        state.mixinCallAfter = false;\n\n        if (!stream.match(/^\\( *[-\\w]+ *=/, false)) {\n          state.javaScriptArguments = true;\n          state.javaScriptArgumentsDepth = 0;\n        }\n\n        return true;\n      }\n    }\n\n    function conditional(stream, state) {\n      if (stream.match(/^(if|unless|else if|else)\\b/)) {\n        state.javaScriptLine = true;\n        return KEYWORD;\n      }\n    }\n\n    function each(stream, state) {\n      if (stream.match(/^(- *)?(each|for)\\b/)) {\n        state.isEach = true;\n        return KEYWORD;\n      }\n    }\n\n    function eachContinued(stream, state) {\n      if (state.isEach) {\n        if (stream.match(/^ in\\b/)) {\n          state.javaScriptLine = true;\n          state.isEach = false;\n          return KEYWORD;\n        } else if (stream.sol() || stream.eol()) {\n          state.isEach = false;\n        } else if (stream.next()) {\n          while (!stream.match(/^ in\\b/, false) && stream.next()) {\n            ;\n          }\n\n          return 'variable';\n        }\n      }\n    }\n\n    function whileStatement(stream, state) {\n      if (stream.match(/^while\\b/)) {\n        state.javaScriptLine = true;\n        return KEYWORD;\n      }\n    }\n\n    function tag(stream, state) {\n      var captures;\n\n      if (captures = stream.match(/^(\\w(?:[-:\\w]*\\w)?)\\/?/)) {\n        state.lastTag = captures[1].toLowerCase();\n\n        if (state.lastTag === 'script') {\n          state.scriptType = 'application/javascript';\n        }\n\n        return 'tag';\n      }\n    }\n\n    function filter(stream, state) {\n      if (stream.match(/^:([\\w\\-]+)/)) {\n        var innerMode;\n\n        if (config && config.innerModes) {\n          innerMode = config.innerModes(stream.current().substring(1));\n        }\n\n        if (!innerMode) {\n          innerMode = stream.current().substring(1);\n        }\n\n        if (typeof innerMode === 'string') {\n          innerMode = CodeMirror.getMode(config, innerMode);\n        }\n\n        setInnerMode(stream, state, innerMode);\n        return 'atom';\n      }\n    }\n\n    function code(stream, state) {\n      if (stream.match(/^(!?=|-)/)) {\n        state.javaScriptLine = true;\n        return 'punctuation';\n      }\n    }\n\n    function id(stream) {\n      if (stream.match(/^#([\\w-]+)/)) {\n        return ID;\n      }\n    }\n\n    function className(stream) {\n      if (stream.match(/^\\.([\\w-]+)/)) {\n        return CLASS;\n      }\n    }\n\n    function attrs(stream, state) {\n      if (stream.peek() == '(') {\n        stream.next();\n        state.isAttrs = true;\n        state.attrsNest = [];\n        state.inAttributeName = true;\n        state.attrValue = '';\n        state.attributeIsType = false;\n        return 'punctuation';\n      }\n    }\n\n    function attrsContinued(stream, state) {\n      if (state.isAttrs) {\n        if (ATTRS_NEST[stream.peek()]) {\n          state.attrsNest.push(ATTRS_NEST[stream.peek()]);\n        }\n\n        if (state.attrsNest[state.attrsNest.length - 1] === stream.peek()) {\n          state.attrsNest.pop();\n        } else if (stream.eat(')')) {\n          state.isAttrs = false;\n          return 'punctuation';\n        }\n\n        if (state.inAttributeName && stream.match(/^[^=,\\)!]+/)) {\n          if (stream.peek() === '=' || stream.peek() === '!') {\n            state.inAttributeName = false;\n            state.jsState = CodeMirror.startState(jsMode);\n\n            if (state.lastTag === 'script' && stream.current().trim().toLowerCase() === 'type') {\n              state.attributeIsType = true;\n            } else {\n              state.attributeIsType = false;\n            }\n          }\n\n          return 'attribute';\n        }\n\n        var tok = jsMode.token(stream, state.jsState);\n\n        if (state.attributeIsType && tok === 'string') {\n          state.scriptType = stream.current().toString();\n        }\n\n        if (state.attrsNest.length === 0 && (tok === 'string' || tok === 'variable' || tok === 'keyword')) {\n          try {\n            Function('', 'var x ' + state.attrValue.replace(/,\\s*$/, '').replace(/^!/, ''));\n            state.inAttributeName = true;\n            state.attrValue = '';\n            stream.backUp(stream.current().length);\n            return attrsContinued(stream, state);\n          } catch (ex) {//not the end of an attribute\n          }\n        }\n\n        state.attrValue += stream.current();\n        return tok || true;\n      }\n    }\n\n    function attributesBlock(stream, state) {\n      if (stream.match(/^&attributes\\b/)) {\n        state.javaScriptArguments = true;\n        state.javaScriptArgumentsDepth = 0;\n        return 'keyword';\n      }\n    }\n\n    function indent(stream) {\n      if (stream.sol() && stream.eatSpace()) {\n        return 'indent';\n      }\n    }\n\n    function comment(stream, state) {\n      if (stream.match(/^ *\\/\\/(-)?([^\\n]*)/)) {\n        state.indentOf = stream.indentation();\n        state.indentToken = 'comment';\n        return 'comment';\n      }\n    }\n\n    function colon(stream) {\n      if (stream.match(/^: */)) {\n        return 'colon';\n      }\n    }\n\n    function text(stream, state) {\n      if (stream.match(/^(?:\\| ?| )([^\\n]+)/)) {\n        return 'string';\n      }\n\n      if (stream.match(/^(<[^\\n]*)/, false)) {\n        // html string\n        setInnerMode(stream, state, 'htmlmixed');\n        state.innerModeForLine = true;\n        return innerMode(stream, state, true);\n      }\n    }\n\n    function dot(stream, state) {\n      if (stream.eat('.')) {\n        var innerMode = null;\n\n        if (state.lastTag === 'script' && state.scriptType.toLowerCase().indexOf('javascript') != -1) {\n          innerMode = state.scriptType.toLowerCase().replace(/\"|'/g, '');\n        } else if (state.lastTag === 'style') {\n          innerMode = 'css';\n        }\n\n        setInnerMode(stream, state, innerMode);\n        return 'dot';\n      }\n    }\n\n    function fail(stream) {\n      stream.next();\n      return null;\n    }\n\n    function setInnerMode(stream, state, mode) {\n      mode = CodeMirror.mimeModes[mode] || mode;\n      mode = config.innerModes ? config.innerModes(mode) || mode : mode;\n      mode = CodeMirror.mimeModes[mode] || mode;\n      mode = CodeMirror.getMode(config, mode);\n      state.indentOf = stream.indentation();\n\n      if (mode && mode.name !== 'null') {\n        state.innerMode = mode;\n      } else {\n        state.indentToken = 'string';\n      }\n    }\n\n    function innerMode(stream, state, force) {\n      if (stream.indentation() > state.indentOf || state.innerModeForLine && !stream.sol() || force) {\n        if (state.innerMode) {\n          if (!state.innerState) {\n            state.innerState = state.innerMode.startState ? CodeMirror.startState(state.innerMode, stream.indentation()) : {};\n          }\n\n          return stream.hideFirstChars(state.indentOf + 2, function () {\n            return state.innerMode.token(stream, state.innerState) || true;\n          });\n        } else {\n          stream.skipToEnd();\n          return state.indentToken;\n        }\n      } else if (stream.sol()) {\n        state.indentOf = Infinity;\n        state.indentToken = null;\n        state.innerMode = null;\n        state.innerState = null;\n      }\n    }\n\n    function restOfLine(stream, state) {\n      if (stream.sol()) {\n        // if restOfLine was set at end of line, ignore it\n        state.restOfLine = '';\n      }\n\n      if (state.restOfLine) {\n        stream.skipToEnd();\n        var tok = state.restOfLine;\n        state.restOfLine = '';\n        return tok;\n      }\n    }\n\n    function startState() {\n      return new State();\n    }\n\n    function copyState(state) {\n      return state.copy();\n    }\n    /**\n     * Get the next token in the stream\n     *\n     * @param {Stream} stream\n     * @param {State} state\n     */\n\n\n    function nextToken(stream, state) {\n      var tok = innerMode(stream, state) || restOfLine(stream, state) || interpolationContinued(stream, state) || includeFilteredContinued(stream, state) || eachContinued(stream, state) || attrsContinued(stream, state) || javaScript(stream, state) || javaScriptArguments(stream, state) || callArguments(stream, state) || yieldStatement(stream, state) || doctype(stream, state) || interpolation(stream, state) || caseStatement(stream, state) || when(stream, state) || defaultStatement(stream, state) || extendsStatement(stream, state) || append(stream, state) || prepend(stream, state) || block(stream, state) || include(stream, state) || includeFiltered(stream, state) || mixin(stream, state) || call(stream, state) || conditional(stream, state) || each(stream, state) || whileStatement(stream, state) || tag(stream, state) || filter(stream, state) || code(stream, state) || id(stream, state) || className(stream, state) || attrs(stream, state) || attributesBlock(stream, state) || indent(stream, state) || text(stream, state) || comment(stream, state) || colon(stream, state) || dot(stream, state) || fail(stream, state);\n      return tok === true ? null : tok;\n    }\n\n    return {\n      startState: startState,\n      copyState: copyState,\n      token: nextToken\n    };\n  }, 'javascript', 'css', 'htmlmixed');\n  CodeMirror.defineMIME('text/x-pug', 'pug');\n  CodeMirror.defineMIME('text/x-jade', 'pug');\n});","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n(function (mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);else // Plain browser env\n    mod(CodeMirror);\n})(function (CodeMirror) {\n  \"use strict\";\n\n  var htmlConfig = {\n    autoSelfClosers: {\n      'area': true,\n      'base': true,\n      'br': true,\n      'col': true,\n      'command': true,\n      'embed': true,\n      'frame': true,\n      'hr': true,\n      'img': true,\n      'input': true,\n      'keygen': true,\n      'link': true,\n      'meta': true,\n      'param': true,\n      'source': true,\n      'track': true,\n      'wbr': true,\n      'menuitem': true\n    },\n    implicitlyClosed: {\n      'dd': true,\n      'li': true,\n      'optgroup': true,\n      'option': true,\n      'p': true,\n      'rp': true,\n      'rt': true,\n      'tbody': true,\n      'td': true,\n      'tfoot': true,\n      'th': true,\n      'tr': true\n    },\n    contextGrabbers: {\n      'dd': {\n        'dd': true,\n        'dt': true\n      },\n      'dt': {\n        'dd': true,\n        'dt': true\n      },\n      'li': {\n        'li': true\n      },\n      'option': {\n        'option': true,\n        'optgroup': true\n      },\n      'optgroup': {\n        'optgroup': true\n      },\n      'p': {\n        'address': true,\n        'article': true,\n        'aside': true,\n        'blockquote': true,\n        'dir': true,\n        'div': true,\n        'dl': true,\n        'fieldset': true,\n        'footer': true,\n        'form': true,\n        'h1': true,\n        'h2': true,\n        'h3': true,\n        'h4': true,\n        'h5': true,\n        'h6': true,\n        'header': true,\n        'hgroup': true,\n        'hr': true,\n        'menu': true,\n        'nav': true,\n        'ol': true,\n        'p': true,\n        'pre': true,\n        'section': true,\n        'table': true,\n        'ul': true\n      },\n      'rp': {\n        'rp': true,\n        'rt': true\n      },\n      'rt': {\n        'rp': true,\n        'rt': true\n      },\n      'tbody': {\n        'tbody': true,\n        'tfoot': true\n      },\n      'td': {\n        'td': true,\n        'th': true\n      },\n      'tfoot': {\n        'tbody': true\n      },\n      'th': {\n        'td': true,\n        'th': true\n      },\n      'thead': {\n        'tbody': true,\n        'tfoot': true\n      },\n      'tr': {\n        'tr': true\n      }\n    },\n    doNotIndent: {\n      \"pre\": true\n    },\n    allowUnquoted: true,\n    allowMissing: true,\n    caseFold: true\n  };\n  var xmlConfig = {\n    autoSelfClosers: {},\n    implicitlyClosed: {},\n    contextGrabbers: {},\n    doNotIndent: {},\n    allowUnquoted: false,\n    allowMissing: false,\n    allowMissingTagName: false,\n    caseFold: false\n  };\n  CodeMirror.defineMode(\"xml\", function (editorConf, config_) {\n    var indentUnit = editorConf.indentUnit;\n    var config = {};\n    var defaults = config_.htmlMode ? htmlConfig : xmlConfig;\n\n    for (var prop in defaults) {\n      config[prop] = defaults[prop];\n    }\n\n    for (var prop in config_) {\n      config[prop] = config_[prop];\n    } // Return variables for tokenizers\n\n\n    var type, setStyle;\n\n    function inText(stream, state) {\n      function chain(parser) {\n        state.tokenize = parser;\n        return parser(stream, state);\n      }\n\n      var ch = stream.next();\n\n      if (ch == \"<\") {\n        if (stream.eat(\"!\")) {\n          if (stream.eat(\"[\")) {\n            if (stream.match(\"CDATA[\")) return chain(inBlock(\"atom\", \"]]>\"));else return null;\n          } else if (stream.match(\"--\")) {\n            return chain(inBlock(\"comment\", \"-->\"));\n          } else if (stream.match(\"DOCTYPE\", true, true)) {\n            stream.eatWhile(/[\\w\\._\\-]/);\n            return chain(doctype(1));\n          } else {\n            return null;\n          }\n        } else if (stream.eat(\"?\")) {\n          stream.eatWhile(/[\\w\\._\\-]/);\n          state.tokenize = inBlock(\"meta\", \"?>\");\n          return \"meta\";\n        } else {\n          type = stream.eat(\"/\") ? \"closeTag\" : \"openTag\";\n          state.tokenize = inTag;\n          return \"tag bracket\";\n        }\n      } else if (ch == \"&\") {\n        var ok;\n\n        if (stream.eat(\"#\")) {\n          if (stream.eat(\"x\")) {\n            ok = stream.eatWhile(/[a-fA-F\\d]/) && stream.eat(\";\");\n          } else {\n            ok = stream.eatWhile(/[\\d]/) && stream.eat(\";\");\n          }\n        } else {\n          ok = stream.eatWhile(/[\\w\\.\\-:]/) && stream.eat(\";\");\n        }\n\n        return ok ? \"atom\" : \"error\";\n      } else {\n        stream.eatWhile(/[^&<]/);\n        return null;\n      }\n    }\n\n    inText.isInText = true;\n\n    function inTag(stream, state) {\n      var ch = stream.next();\n\n      if (ch == \">\" || ch == \"/\" && stream.eat(\">\")) {\n        state.tokenize = inText;\n        type = ch == \">\" ? \"endTag\" : \"selfcloseTag\";\n        return \"tag bracket\";\n      } else if (ch == \"=\") {\n        type = \"equals\";\n        return null;\n      } else if (ch == \"<\") {\n        state.tokenize = inText;\n        state.state = baseState;\n        state.tagName = state.tagStart = null;\n        var next = state.tokenize(stream, state);\n        return next ? next + \" tag error\" : \"tag error\";\n      } else if (/[\\'\\\"]/.test(ch)) {\n        state.tokenize = inAttribute(ch);\n        state.stringStartCol = stream.column();\n        return state.tokenize(stream, state);\n      } else {\n        stream.match(/^[^\\s\\u00a0=<>\\\"\\']*[^\\s\\u00a0=<>\\\"\\'\\/]/);\n        return \"word\";\n      }\n    }\n\n    function inAttribute(quote) {\n      var closure = function closure(stream, state) {\n        while (!stream.eol()) {\n          if (stream.next() == quote) {\n            state.tokenize = inTag;\n            break;\n          }\n        }\n\n        return \"string\";\n      };\n\n      closure.isInAttribute = true;\n      return closure;\n    }\n\n    function inBlock(style, terminator) {\n      return function (stream, state) {\n        while (!stream.eol()) {\n          if (stream.match(terminator)) {\n            state.tokenize = inText;\n            break;\n          }\n\n          stream.next();\n        }\n\n        return style;\n      };\n    }\n\n    function doctype(depth) {\n      return function (stream, state) {\n        var ch;\n\n        while ((ch = stream.next()) != null) {\n          if (ch == \"<\") {\n            state.tokenize = doctype(depth + 1);\n            return state.tokenize(stream, state);\n          } else if (ch == \">\") {\n            if (depth == 1) {\n              state.tokenize = inText;\n              break;\n            } else {\n              state.tokenize = doctype(depth - 1);\n              return state.tokenize(stream, state);\n            }\n          }\n        }\n\n        return \"meta\";\n      };\n    }\n\n    function Context(state, tagName, startOfLine) {\n      this.prev = state.context;\n      this.tagName = tagName;\n      this.indent = state.indented;\n      this.startOfLine = startOfLine;\n      if (config.doNotIndent.hasOwnProperty(tagName) || state.context && state.context.noIndent) this.noIndent = true;\n    }\n\n    function popContext(state) {\n      if (state.context) state.context = state.context.prev;\n    }\n\n    function maybePopContext(state, nextTagName) {\n      var parentTagName;\n\n      while (true) {\n        if (!state.context) {\n          return;\n        }\n\n        parentTagName = state.context.tagName;\n\n        if (!config.contextGrabbers.hasOwnProperty(parentTagName) || !config.contextGrabbers[parentTagName].hasOwnProperty(nextTagName)) {\n          return;\n        }\n\n        popContext(state);\n      }\n    }\n\n    function baseState(type, stream, state) {\n      if (type == \"openTag\") {\n        state.tagStart = stream.column();\n        return tagNameState;\n      } else if (type == \"closeTag\") {\n        return closeTagNameState;\n      } else {\n        return baseState;\n      }\n    }\n\n    function tagNameState(type, stream, state) {\n      if (type == \"word\") {\n        state.tagName = stream.current();\n        setStyle = \"tag\";\n        return attrState;\n      } else if (config.allowMissingTagName && type == \"endTag\") {\n        setStyle = \"tag bracket\";\n        return attrState(type, stream, state);\n      } else {\n        setStyle = \"error\";\n        return tagNameState;\n      }\n    }\n\n    function closeTagNameState(type, stream, state) {\n      if (type == \"word\") {\n        var tagName = stream.current();\n        if (state.context && state.context.tagName != tagName && config.implicitlyClosed.hasOwnProperty(state.context.tagName)) popContext(state);\n\n        if (state.context && state.context.tagName == tagName || config.matchClosing === false) {\n          setStyle = \"tag\";\n          return closeState;\n        } else {\n          setStyle = \"tag error\";\n          return closeStateErr;\n        }\n      } else if (config.allowMissingTagName && type == \"endTag\") {\n        setStyle = \"tag bracket\";\n        return closeState(type, stream, state);\n      } else {\n        setStyle = \"error\";\n        return closeStateErr;\n      }\n    }\n\n    function closeState(type, _stream, state) {\n      if (type != \"endTag\") {\n        setStyle = \"error\";\n        return closeState;\n      }\n\n      popContext(state);\n      return baseState;\n    }\n\n    function closeStateErr(type, stream, state) {\n      setStyle = \"error\";\n      return closeState(type, stream, state);\n    }\n\n    function attrState(type, _stream, state) {\n      if (type == \"word\") {\n        setStyle = \"attribute\";\n        return attrEqState;\n      } else if (type == \"endTag\" || type == \"selfcloseTag\") {\n        var tagName = state.tagName,\n            tagStart = state.tagStart;\n        state.tagName = state.tagStart = null;\n\n        if (type == \"selfcloseTag\" || config.autoSelfClosers.hasOwnProperty(tagName)) {\n          maybePopContext(state, tagName);\n        } else {\n          maybePopContext(state, tagName);\n          state.context = new Context(state, tagName, tagStart == state.indented);\n        }\n\n        return baseState;\n      }\n\n      setStyle = \"error\";\n      return attrState;\n    }\n\n    function attrEqState(type, stream, state) {\n      if (type == \"equals\") return attrValueState;\n      if (!config.allowMissing) setStyle = \"error\";\n      return attrState(type, stream, state);\n    }\n\n    function attrValueState(type, stream, state) {\n      if (type == \"string\") return attrContinuedState;\n\n      if (type == \"word\" && config.allowUnquoted) {\n        setStyle = \"string\";\n        return attrState;\n      }\n\n      setStyle = \"error\";\n      return attrState(type, stream, state);\n    }\n\n    function attrContinuedState(type, stream, state) {\n      if (type == \"string\") return attrContinuedState;\n      return attrState(type, stream, state);\n    }\n\n    return {\n      startState: function startState(baseIndent) {\n        var state = {\n          tokenize: inText,\n          state: baseState,\n          indented: baseIndent || 0,\n          tagName: null,\n          tagStart: null,\n          context: null\n        };\n        if (baseIndent != null) state.baseIndent = baseIndent;\n        return state;\n      },\n      token: function token(stream, state) {\n        if (!state.tagName && stream.sol()) state.indented = stream.indentation();\n        if (stream.eatSpace()) return null;\n        type = null;\n        var style = state.tokenize(stream, state);\n\n        if ((style || type) && style != \"comment\") {\n          setStyle = null;\n          state.state = state.state(type || style, stream, state);\n          if (setStyle) style = setStyle == \"error\" ? style + \" error\" : setStyle;\n        }\n\n        return style;\n      },\n      indent: function indent(state, textAfter, fullLine) {\n        var context = state.context; // Indent multi-line strings (e.g. css).\n\n        if (state.tokenize.isInAttribute) {\n          if (state.tagStart == state.indented) return state.stringStartCol + 1;else return state.indented + indentUnit;\n        }\n\n        if (context && context.noIndent) return CodeMirror.Pass;\n        if (state.tokenize != inTag && state.tokenize != inText) return fullLine ? fullLine.match(/^(\\s*)/)[0].length : 0; // Indent the starts of attribute names.\n\n        if (state.tagName) {\n          if (config.multilineTagIndentPastTag !== false) return state.tagStart + state.tagName.length + 2;else return state.tagStart + indentUnit * (config.multilineTagIndentFactor || 1);\n        }\n\n        if (config.alignCDATA && /<!\\[CDATA\\[/.test(textAfter)) return 0;\n        var tagAfter = textAfter && /^<(\\/)?([\\w_:\\.-]*)/.exec(textAfter);\n\n        if (tagAfter && tagAfter[1]) {\n          // Closing tag spotted\n          while (context) {\n            if (context.tagName == tagAfter[2]) {\n              context = context.prev;\n              break;\n            } else if (config.implicitlyClosed.hasOwnProperty(context.tagName)) {\n              context = context.prev;\n            } else {\n              break;\n            }\n          }\n        } else if (tagAfter) {\n          // Opening tag spotted\n          while (context) {\n            var grabbers = config.contextGrabbers[context.tagName];\n            if (grabbers && grabbers.hasOwnProperty(tagAfter[2])) context = context.prev;else break;\n          }\n        }\n\n        while (context && context.prev && !context.startOfLine) {\n          context = context.prev;\n        }\n\n        if (context) return context.indent + indentUnit;else return state.baseIndent || 0;\n      },\n      electricInput: /<\\/[\\s\\w:]+>$/,\n      blockCommentStart: \"<!--\",\n      blockCommentEnd: \"-->\",\n      configuration: config.htmlMode ? \"html\" : \"xml\",\n      helperType: config.htmlMode ? \"html\" : \"xml\",\n      skipAttribute: function skipAttribute(state) {\n        if (state.state == attrValueState) state.state = attrState;\n      }\n    };\n  });\n  CodeMirror.defineMIME(\"text/xml\", \"xml\");\n  CodeMirror.defineMIME(\"application/xml\", \"xml\");\n  if (!CodeMirror.mimeModes.hasOwnProperty(\"text/html\")) CodeMirror.defineMIME(\"text/html\", {\n    name: \"xml\",\n    htmlMode: true\n  });\n});","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n(function (mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"), require(\"../xml/xml\"), require(\"../javascript/javascript\"), require(\"../css/css\"));else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\", \"../xml/xml\", \"../javascript/javascript\", \"../css/css\"], mod);else // Plain browser env\n    mod(CodeMirror);\n})(function (CodeMirror) {\n  \"use strict\";\n\n  var defaultTags = {\n    script: [[\"lang\", /(javascript|babel)/i, \"javascript\"], [\"type\", /^(?:text|application)\\/(?:x-)?(?:java|ecma)script$|^module$|^$/i, \"javascript\"], [\"type\", /./, \"text/plain\"], [null, null, \"javascript\"]],\n    style: [[\"lang\", /^css$/i, \"css\"], [\"type\", /^(text\\/)?(x-)?(stylesheet|css)$/i, \"css\"], [\"type\", /./, \"text/plain\"], [null, null, \"css\"]]\n  };\n\n  function maybeBackup(stream, pat, style) {\n    var cur = stream.current(),\n        close = cur.search(pat);\n\n    if (close > -1) {\n      stream.backUp(cur.length - close);\n    } else if (cur.match(/<\\/?$/)) {\n      stream.backUp(cur.length);\n      if (!stream.match(pat, false)) stream.match(cur);\n    }\n\n    return style;\n  }\n\n  var attrRegexpCache = {};\n\n  function getAttrRegexp(attr) {\n    var regexp = attrRegexpCache[attr];\n    if (regexp) return regexp;\n    return attrRegexpCache[attr] = new RegExp(\"\\\\s+\" + attr + \"\\\\s*=\\\\s*('|\\\")?([^'\\\"]+)('|\\\")?\\\\s*\");\n  }\n\n  function getAttrValue(text, attr) {\n    var match = text.match(getAttrRegexp(attr));\n    return match ? /^\\s*(.*?)\\s*$/.exec(match[2])[1] : \"\";\n  }\n\n  function getTagRegexp(tagName, anchored) {\n    return new RegExp((anchored ? \"^\" : \"\") + \"<\\/\\s*\" + tagName + \"\\s*>\", \"i\");\n  }\n\n  function addTags(from, to) {\n    for (var tag in from) {\n      var dest = to[tag] || (to[tag] = []);\n      var source = from[tag];\n\n      for (var i = source.length - 1; i >= 0; i--) {\n        dest.unshift(source[i]);\n      }\n    }\n  }\n\n  function findMatchingMode(tagInfo, tagText) {\n    for (var i = 0; i < tagInfo.length; i++) {\n      var spec = tagInfo[i];\n      if (!spec[0] || spec[1].test(getAttrValue(tagText, spec[0]))) return spec[2];\n    }\n  }\n\n  CodeMirror.defineMode(\"htmlmixed\", function (config, parserConfig) {\n    var htmlMode = CodeMirror.getMode(config, {\n      name: \"xml\",\n      htmlMode: true,\n      multilineTagIndentFactor: parserConfig.multilineTagIndentFactor,\n      multilineTagIndentPastTag: parserConfig.multilineTagIndentPastTag\n    });\n    var tags = {};\n    var configTags = parserConfig && parserConfig.tags,\n        configScript = parserConfig && parserConfig.scriptTypes;\n    addTags(defaultTags, tags);\n    if (configTags) addTags(configTags, tags);\n    if (configScript) for (var i = configScript.length - 1; i >= 0; i--) {\n      tags.script.unshift([\"type\", configScript[i].matches, configScript[i].mode]);\n    }\n\n    function html(stream, state) {\n      var style = htmlMode.token(stream, state.htmlState),\n          tag = /\\btag\\b/.test(style),\n          tagName;\n\n      if (tag && !/[<>\\s\\/]/.test(stream.current()) && (tagName = state.htmlState.tagName && state.htmlState.tagName.toLowerCase()) && tags.hasOwnProperty(tagName)) {\n        state.inTag = tagName + \" \";\n      } else if (state.inTag && tag && />$/.test(stream.current())) {\n        var inTag = /^([\\S]+) (.*)/.exec(state.inTag);\n        state.inTag = null;\n        var modeSpec = stream.current() == \">\" && findMatchingMode(tags[inTag[1]], inTag[2]);\n        var mode = CodeMirror.getMode(config, modeSpec);\n        var endTagA = getTagRegexp(inTag[1], true),\n            endTag = getTagRegexp(inTag[1], false);\n\n        state.token = function (stream, state) {\n          if (stream.match(endTagA, false)) {\n            state.token = html;\n            state.localState = state.localMode = null;\n            return null;\n          }\n\n          return maybeBackup(stream, endTag, state.localMode.token(stream, state.localState));\n        };\n\n        state.localMode = mode;\n        state.localState = CodeMirror.startState(mode, htmlMode.indent(state.htmlState, \"\"));\n      } else if (state.inTag) {\n        state.inTag += stream.current();\n        if (stream.eol()) state.inTag += \" \";\n      }\n\n      return style;\n    }\n\n    ;\n    return {\n      startState: function startState() {\n        var state = CodeMirror.startState(htmlMode);\n        return {\n          token: html,\n          inTag: null,\n          localMode: null,\n          localState: null,\n          htmlState: state\n        };\n      },\n      copyState: function copyState(state) {\n        var local;\n\n        if (state.localState) {\n          local = CodeMirror.copyState(state.localMode, state.localState);\n        }\n\n        return {\n          token: state.token,\n          inTag: state.inTag,\n          localMode: state.localMode,\n          localState: local,\n          htmlState: CodeMirror.copyState(htmlMode, state.htmlState)\n        };\n      },\n      token: function token(stream, state) {\n        return state.token(stream, state);\n      },\n      indent: function indent(state, textAfter, line) {\n        if (!state.localMode || /^\\s*<\\//.test(textAfter)) return htmlMode.indent(state.htmlState, textAfter);else if (state.localMode.indent) return state.localMode.indent(state.localState, textAfter, line);else return CodeMirror.Pass;\n      },\n      innerMode: function innerMode(state) {\n        return {\n          state: state.localState || state.htmlState,\n          mode: state.localMode || htmlMode\n        };\n      }\n    };\n  }, \"xml\", \"javascript\", \"css\");\n  CodeMirror.defineMIME(\"text/html\", \"htmlmixed\");\n});"],"sourceRoot":""}