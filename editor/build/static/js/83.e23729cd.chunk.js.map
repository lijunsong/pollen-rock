{"version":3,"sources":["../node_modules/codemirror/mode/smarty/smarty.js"],"names":["CodeMirror","defineMode","config","parserConf","last","rightDelimiter","leftDelimiter","version","baseMode","getMode","keyFunctions","regs","operatorChars","validIdentifier","stringChar","cont","style","lastType","doesNotCount","stream","pos","string","length","test","charAt","tokenTop","state","terminator","scan","nextMatch","indexOf","match","eat","parser","tokenize","chain","eol","next","depth","tokenSmarty","slice","token","base","ch","eatWhile","quote","prevChar","currChar","peek","str","c","i","j","startState","copyState","innerMode","mode","indent","text","Pass","blockCommentStart","blockCommentEnd","defineMIME","mod","__webpack_require__"],"mappings":"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","file":"static/js/83.e23729cd.chunk.js","sourcesContent":["// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n\n/**\n * Smarty 2 and 3 mode.\n */\n(function (mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);else // Plain browser env\n    mod(CodeMirror);\n})(function (CodeMirror) {\n  \"use strict\";\n\n  CodeMirror.defineMode(\"smarty\", function (config, parserConf) {\n    var rightDelimiter = parserConf.rightDelimiter || \"}\";\n    var leftDelimiter = parserConf.leftDelimiter || \"{\";\n    var version = parserConf.version || 2;\n    var baseMode = CodeMirror.getMode(config, parserConf.baseMode || \"null\");\n    var keyFunctions = [\"debug\", \"extends\", \"function\", \"include\", \"literal\"];\n    var regs = {\n      operatorChars: /[+\\-*&%=<>!?]/,\n      validIdentifier: /[a-zA-Z0-9_]/,\n      stringChar: /['\"]/\n    };\n    var last;\n\n    function cont(style, lastType) {\n      last = lastType;\n      return style;\n    }\n\n    function chain(stream, state, parser) {\n      state.tokenize = parser;\n      return parser(stream, state);\n    } // Smarty 3 allows { and } surrounded by whitespace to NOT slip into Smarty mode\n\n\n    function doesNotCount(stream, pos) {\n      if (pos == null) pos = stream.pos;\n      return version === 3 && leftDelimiter == \"{\" && (pos == stream.string.length || /\\s/.test(stream.string.charAt(pos)));\n    }\n\n    function tokenTop(stream, state) {\n      var string = stream.string;\n\n      for (var scan = stream.pos;;) {\n        var nextMatch = string.indexOf(leftDelimiter, scan);\n        scan = nextMatch + leftDelimiter.length;\n        if (nextMatch == -1 || !doesNotCount(stream, nextMatch + leftDelimiter.length)) break;\n      }\n\n      if (nextMatch == stream.pos) {\n        stream.match(leftDelimiter);\n\n        if (stream.eat(\"*\")) {\n          return chain(stream, state, tokenBlock(\"comment\", \"*\" + rightDelimiter));\n        } else {\n          state.depth++;\n          state.tokenize = tokenSmarty;\n          last = \"startTag\";\n          return \"tag\";\n        }\n      }\n\n      if (nextMatch > -1) stream.string = string.slice(0, nextMatch);\n      var token = baseMode.token(stream, state.base);\n      if (nextMatch > -1) stream.string = string;\n      return token;\n    } // parsing Smarty content\n\n\n    function tokenSmarty(stream, state) {\n      if (stream.match(rightDelimiter, true)) {\n        if (version === 3) {\n          state.depth--;\n\n          if (state.depth <= 0) {\n            state.tokenize = tokenTop;\n          }\n        } else {\n          state.tokenize = tokenTop;\n        }\n\n        return cont(\"tag\", null);\n      }\n\n      if (stream.match(leftDelimiter, true)) {\n        state.depth++;\n        return cont(\"tag\", \"startTag\");\n      }\n\n      var ch = stream.next();\n\n      if (ch == \"$\") {\n        stream.eatWhile(regs.validIdentifier);\n        return cont(\"variable-2\", \"variable\");\n      } else if (ch == \"|\") {\n        return cont(\"operator\", \"pipe\");\n      } else if (ch == \".\") {\n        return cont(\"operator\", \"property\");\n      } else if (regs.stringChar.test(ch)) {\n        state.tokenize = tokenAttribute(ch);\n        return cont(\"string\", \"string\");\n      } else if (regs.operatorChars.test(ch)) {\n        stream.eatWhile(regs.operatorChars);\n        return cont(\"operator\", \"operator\");\n      } else if (ch == \"[\" || ch == \"]\") {\n        return cont(\"bracket\", \"bracket\");\n      } else if (ch == \"(\" || ch == \")\") {\n        return cont(\"bracket\", \"operator\");\n      } else if (/\\d/.test(ch)) {\n        stream.eatWhile(/\\d/);\n        return cont(\"number\", \"number\");\n      } else {\n        if (state.last == \"variable\") {\n          if (ch == \"@\") {\n            stream.eatWhile(regs.validIdentifier);\n            return cont(\"property\", \"property\");\n          } else if (ch == \"|\") {\n            stream.eatWhile(regs.validIdentifier);\n            return cont(\"qualifier\", \"modifier\");\n          }\n        } else if (state.last == \"pipe\") {\n          stream.eatWhile(regs.validIdentifier);\n          return cont(\"qualifier\", \"modifier\");\n        } else if (state.last == \"whitespace\") {\n          stream.eatWhile(regs.validIdentifier);\n          return cont(\"attribute\", \"modifier\");\n        }\n\n        if (state.last == \"property\") {\n          stream.eatWhile(regs.validIdentifier);\n          return cont(\"property\", null);\n        } else if (/\\s/.test(ch)) {\n          last = \"whitespace\";\n          return null;\n        }\n\n        var str = \"\";\n\n        if (ch != \"/\") {\n          str += ch;\n        }\n\n        var c = null;\n\n        while (c = stream.eat(regs.validIdentifier)) {\n          str += c;\n        }\n\n        for (var i = 0, j = keyFunctions.length; i < j; i++) {\n          if (keyFunctions[i] == str) {\n            return cont(\"keyword\", \"keyword\");\n          }\n        }\n\n        if (/\\s/.test(ch)) {\n          return null;\n        }\n\n        return cont(\"tag\", \"tag\");\n      }\n    }\n\n    function tokenAttribute(quote) {\n      return function (stream, state) {\n        var prevChar = null;\n        var currChar = null;\n\n        while (!stream.eol()) {\n          currChar = stream.peek();\n\n          if (stream.next() == quote && prevChar !== '\\\\') {\n            state.tokenize = tokenSmarty;\n            break;\n          }\n\n          prevChar = currChar;\n        }\n\n        return \"string\";\n      };\n    }\n\n    function tokenBlock(style, terminator) {\n      return function (stream, state) {\n        while (!stream.eol()) {\n          if (stream.match(terminator)) {\n            state.tokenize = tokenTop;\n            break;\n          }\n\n          stream.next();\n        }\n\n        return style;\n      };\n    }\n\n    return {\n      startState: function startState() {\n        return {\n          base: CodeMirror.startState(baseMode),\n          tokenize: tokenTop,\n          last: null,\n          depth: 0\n        };\n      },\n      copyState: function copyState(state) {\n        return {\n          base: CodeMirror.copyState(baseMode, state.base),\n          tokenize: state.tokenize,\n          last: state.last,\n          depth: state.depth\n        };\n      },\n      innerMode: function innerMode(state) {\n        if (state.tokenize == tokenTop) return {\n          mode: baseMode,\n          state: state.base\n        };\n      },\n      token: function token(stream, state) {\n        var style = state.tokenize(stream, state);\n        state.last = last;\n        return style;\n      },\n      indent: function indent(state, text) {\n        if (state.tokenize == tokenTop && baseMode.indent) return baseMode.indent(state.base, text);else return CodeMirror.Pass;\n      },\n      blockCommentStart: leftDelimiter + \"*\",\n      blockCommentEnd: \"*\" + rightDelimiter\n    };\n  });\n  CodeMirror.defineMIME(\"text/x-smarty\", \"smarty\");\n});"],"sourceRoot":""}