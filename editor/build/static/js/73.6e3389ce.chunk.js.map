{"version":3,"sources":["../node_modules/codemirror/mode/r/r.js"],"names":["CodeMirror","registerHelper","defineMode","config","wordObj","words","res","i","length","commonAtoms","commonBuiltins","commonKeywords","concat","curPunc","atoms","builtins","keywords","blockkeywords","opChars","tokenBase","stream","state","quote","ch","next","skipToEnd","eat","eatWhile","match","test","tokenize","skipTo","backUp","word","current","propertyIsEnumerable","ctx","argList","push","type","indent","flags","column","prev","setFlag","flag","pop","startState","indentUnit","afterIdent","token","sol","indentation","eatSpace","style","textAfter","firstChar","charAt","closing","lineComment","defineMIME","mod","__webpack_require__"],"mappings":"+EAOC,SAAAA,GACD,aAEAA,EAAAC,eAAA,yBACAD,EAAAE,WAAA,aAAAC,GACA,SAAAC,EAAAC,GAGA,IAFA,IAAAC,EAAA,GAEAC,EAAA,EAAqBA,EAAAF,EAAAG,SAAkBD,EACvCD,EAAAD,EAAAE,KAAA,EAGA,OAAAD,EAGA,IAAAG,EAAA,gGACAC,EAAA,mEACAC,EAAA,oEAEAX,EAAAC,eAAA,gBAAAQ,EAAAG,OAAAF,EAAAC,IACA,IAKAE,EALAC,EAAAV,EAAAK,GACAM,EAAAX,EAAAM,GACAM,EAAAZ,EAAAO,GACAM,EAAAb,EALA,iDAMAc,EAAA,qBAGA,SAAAC,EAAAC,EAAAC,GACAR,EAAA,KACA,IAwDAS,EAxDAC,EAAAH,EAAAI,OAEA,QAAAD,EAEA,OADAH,EAAAK,YACA,UACO,QAAAF,GAAAH,EAAAM,IAAA,KAEP,OADAN,EAAAO,SAAA,YACA,SACO,QAAAJ,GAAAH,EAAAM,IAAA,MAEP,OADAN,EAAAQ,MAAA,sBACA,SACO,QAAAC,KAAAN,GAEP,OADAH,EAAAQ,MAAA,iCACA,SACO,QAAAL,GAAA,KAAAA,EAEP,OADAF,EAAAS,UAyCAR,EAzCAC,EA0CA,SAAAH,EAAAC,GACA,GAAAD,EAAAM,IAAA,OACA,IAAAH,EAAAH,EAAAI,OAEA,MADA,KAAAD,EAAAH,EAAAQ,MAAA,kBAAuD,KAAAL,GAAA,KAAAA,IAAAH,EAAAM,IAAA,MAAkDN,EAAAW,OAAA,KAAsBX,EAAAI,OAAkB,KAAAD,EAAAH,EAAAQ,MAAA,iBAAkD,KAAAL,EAAAH,EAAAQ,MAAA,iBAAkD,QAAAC,KAAAN,IAAAH,EAAAQ,MAAA,eACrP,WAIA,IAFA,IAAAJ,EAEA,OAAAA,EAAAJ,EAAAI,SAAA,CACA,GAAAA,GAAAF,EAAA,CACAD,EAAAS,SAAAX,EACA,MAGA,SAAAK,EAAA,CACAJ,EAAAY,OAAA,GACA,OAIA,iBA7DA,SACO,QAAAT,EAEP,OADAH,EAAAQ,MAAA,UACA,aACO,QAAAL,GAAAH,EAAAQ,MAAA,WACP,gBACO,YAAAC,KAAAN,IAAA,KAAAA,EAAA,CACPH,EAAAO,SAAA,UACA,IAAAM,EAAAb,EAAAc,UACA,OAAApB,EAAAqB,qBAAAF,GAAA,OAEAjB,EAAAmB,qBAAAF,IAGAhB,EAAAkB,qBAAAF,KAAAb,EAAAQ,MAAA,qBAAAf,EAAA,SACA,WAGAE,EAAAoB,qBAAAF,GAAA,UACA,WACO,WAAAV,GACPH,EAAAW,OAAA,MAAAX,EAAAI,OACA,uBACO,KAAAD,GAAAH,EAAAM,IAAA,WAAAH,GAAAH,EAAAQ,MAAA,YAAAL,GAAAH,EAAAQ,MAAA,OACP,iBACO,KAAAL,GAAAF,EAAAe,IAAAC,QACP,SACOnB,EAAAW,KAAAN,GACP,KAAAA,EAAA,mBACAH,EAAAO,SAAAT,GACA,YACO,gBAAuBW,KAAAN,IAC9BV,EAAAU,EACA,KAAAA,EAAoB,OACpB,MAEA,KAkCA,SAAAe,EAAAjB,EAAAkB,EAAAnB,GACAC,EAAAe,IAAA,CACAG,OACAC,OAAAnB,EAAAmB,OACAC,MAAA,EACAC,OAAAtB,EAAAsB,SACAC,KAAAtB,EAAAe,KAIA,SAAAQ,EAAAvB,EAAAwB,GACA,IAAAT,EAAAf,EAAAe,IACAf,EAAAe,IAAA,CACAG,KAAAH,EAAAG,KACAC,OAAAJ,EAAAI,OACAC,MAAAL,EAAAK,MAAAI,EACAH,OAAAN,EAAAM,OACAC,KAAAP,EAAAO,MAIA,SAAAG,EAAAzB,GACAA,EAAAmB,OAAAnB,EAAAe,IAAAI,OACAnB,EAAAe,IAAAf,EAAAe,IAAAO,KAGA,OACAI,WAAA,WACA,OACAjB,SAAAX,EACAiB,IAAA,CACAG,KAAA,MACAC,QAAArC,EAAA6C,WACAP,MApCA,GAsCAD,OAAA,EACAS,YAAA,IAGAC,MAAA,SAAA9B,EAAAC,GAOA,GANAD,EAAA+B,QACA,MAAA9B,EAAAe,IAAAK,SAAApB,EAAAe,IAAAK,OA5CA,GACA,EA4CApB,EAAAe,IAAAK,OAAAK,EAAAzB,GACAA,EAAAmB,OAAApB,EAAAgC,eAGAhC,EAAAiC,WAAA,YACA,IAAAC,EAAAjC,EAAAS,SAAAV,EAAAC,GAQA,MAPA,WAAAiC,GAAA,IAnDA,EAmDAjC,EAAAe,IAAAK,QAAAG,EAAAvB,EApDA,GAqDA,KAAAR,GAA0B,KAAAA,GAAkB,KAAAA,GAAkB,SAAAQ,EAAAe,IAAAG,MAAAO,EAAAzB,GAC9D,KAAAR,EAAyByB,EAAAjB,EAAA,IAAiBD,GAAW,KAAAP,GACrDyB,EAAAjB,EAAA,IAAAD,GACAC,EAAA4B,aAAA5B,EAAAe,IAAAC,SAAA,IACS,KAAAxB,EAAAyB,EAAAjB,EAAA,IAAAD,GAAmD,SAAAP,EAAAyB,EAAAjB,EAAA,QAAAD,GAA0DP,GAAAQ,EAAAe,IAAAG,KAAAO,EAAAzB,GAA+C,SAAAA,EAAAe,IAAAG,MAAA,WAAAe,GAAAV,EAAAvB,EAvDrK,GAwDAA,EAAA4B,WAAA,YAAAK,GAAA,WAAAA,EACAA,GAEAd,OAAA,SAAAnB,EAAAkC,GACA,GAAAlC,EAAAS,UAAAX,EAAA,SACA,IAAAqC,EAAAD,KAAAE,OAAA,GACArB,EAAAf,EAAAe,IACAsB,EAAAF,GAAApB,EAAAG,KAEA,OAjEA,EAgEAH,EAAAK,QAAAL,IAAAO,MACA,SAAAP,EAAAG,KAAAH,EAAAI,QAAA,KAAAgB,EAAqE,EAAArD,EAAA6C,YAnErE,EAmEgGZ,EAAAK,MAAAL,EAAAM,QAAAgB,EAAA,KAAsEtB,EAAAI,QAAAkB,EAAA,EAAAvD,EAAA6C,aAEtKW,YAAA,OAGA3D,EAAA4D,WAAA,mBA1LAC,CAAQC,EAAQ","file":"static/js/73.6e3389ce.chunk.js","sourcesContent":["// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n(function (mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);else // Plain browser env\n    mod(CodeMirror);\n})(function (CodeMirror) {\n  \"use strict\";\n\n  CodeMirror.registerHelper(\"wordChars\", \"r\", /[\\w.]/);\n  CodeMirror.defineMode(\"r\", function (config) {\n    function wordObj(words) {\n      var res = {};\n\n      for (var i = 0; i < words.length; ++i) {\n        res[words[i]] = true;\n      }\n\n      return res;\n    }\n\n    var commonAtoms = [\"NULL\", \"NA\", \"Inf\", \"NaN\", \"NA_integer_\", \"NA_real_\", \"NA_complex_\", \"NA_character_\", \"TRUE\", \"FALSE\"];\n    var commonBuiltins = [\"list\", \"quote\", \"bquote\", \"eval\", \"return\", \"call\", \"parse\", \"deparse\"];\n    var commonKeywords = [\"if\", \"else\", \"repeat\", \"while\", \"function\", \"for\", \"in\", \"next\", \"break\"];\n    var commonBlockKeywords = [\"if\", \"else\", \"repeat\", \"while\", \"function\", \"for\"];\n    CodeMirror.registerHelper(\"hintWords\", \"r\", commonAtoms.concat(commonBuiltins, commonKeywords));\n    var atoms = wordObj(commonAtoms);\n    var builtins = wordObj(commonBuiltins);\n    var keywords = wordObj(commonKeywords);\n    var blockkeywords = wordObj(commonBlockKeywords);\n    var opChars = /[+\\-*\\/^<>=!&|~$:]/;\n    var curPunc;\n\n    function tokenBase(stream, state) {\n      curPunc = null;\n      var ch = stream.next();\n\n      if (ch == \"#\") {\n        stream.skipToEnd();\n        return \"comment\";\n      } else if (ch == \"0\" && stream.eat(\"x\")) {\n        stream.eatWhile(/[\\da-f]/i);\n        return \"number\";\n      } else if (ch == \".\" && stream.eat(/\\d/)) {\n        stream.match(/\\d*(?:e[+\\-]?\\d+)?/);\n        return \"number\";\n      } else if (/\\d/.test(ch)) {\n        stream.match(/\\d*(?:\\.\\d+)?(?:e[+\\-]\\d+)?L?/);\n        return \"number\";\n      } else if (ch == \"'\" || ch == '\"') {\n        state.tokenize = tokenString(ch);\n        return \"string\";\n      } else if (ch == \"`\") {\n        stream.match(/[^`]+`/);\n        return \"variable-3\";\n      } else if (ch == \".\" && stream.match(/.[.\\d]+/)) {\n        return \"keyword\";\n      } else if (/[\\w\\.]/.test(ch) && ch != \"_\") {\n        stream.eatWhile(/[\\w\\.]/);\n        var word = stream.current();\n        if (atoms.propertyIsEnumerable(word)) return \"atom\";\n\n        if (keywords.propertyIsEnumerable(word)) {\n          // Block keywords start new blocks, except 'else if', which only starts\n          // one new block for the 'if', no block for the 'else'.\n          if (blockkeywords.propertyIsEnumerable(word) && !stream.match(/\\s*if(\\s+|$)/, false)) curPunc = \"block\";\n          return \"keyword\";\n        }\n\n        if (builtins.propertyIsEnumerable(word)) return \"builtin\";\n        return \"variable\";\n      } else if (ch == \"%\") {\n        if (stream.skipTo(\"%\")) stream.next();\n        return \"operator variable-2\";\n      } else if (ch == \"<\" && stream.eat(\"-\") || ch == \"<\" && stream.match(\"<-\") || ch == \"-\" && stream.match(/>>?/)) {\n        return \"operator arrow\";\n      } else if (ch == \"=\" && state.ctx.argList) {\n        return \"arg-is\";\n      } else if (opChars.test(ch)) {\n        if (ch == \"$\") return \"operator dollar\";\n        stream.eatWhile(opChars);\n        return \"operator\";\n      } else if (/[\\(\\){}\\[\\];]/.test(ch)) {\n        curPunc = ch;\n        if (ch == \";\") return \"semi\";\n        return null;\n      } else {\n        return null;\n      }\n    }\n\n    function tokenString(quote) {\n      return function (stream, state) {\n        if (stream.eat(\"\\\\\")) {\n          var ch = stream.next();\n          if (ch == \"x\") stream.match(/^[a-f0-9]{2}/i);else if ((ch == \"u\" || ch == \"U\") && stream.eat(\"{\") && stream.skipTo(\"}\")) stream.next();else if (ch == \"u\") stream.match(/^[a-f0-9]{4}/i);else if (ch == \"U\") stream.match(/^[a-f0-9]{8}/i);else if (/[0-7]/.test(ch)) stream.match(/^[0-7]{1,2}/);\n          return \"string-2\";\n        } else {\n          var next;\n\n          while ((next = stream.next()) != null) {\n            if (next == quote) {\n              state.tokenize = tokenBase;\n              break;\n            }\n\n            if (next == \"\\\\\") {\n              stream.backUp(1);\n              break;\n            }\n          }\n\n          return \"string\";\n        }\n      };\n    }\n\n    var ALIGN_YES = 1,\n        ALIGN_NO = 2,\n        BRACELESS = 4;\n\n    function push(state, type, stream) {\n      state.ctx = {\n        type: type,\n        indent: state.indent,\n        flags: 0,\n        column: stream.column(),\n        prev: state.ctx\n      };\n    }\n\n    function setFlag(state, flag) {\n      var ctx = state.ctx;\n      state.ctx = {\n        type: ctx.type,\n        indent: ctx.indent,\n        flags: ctx.flags | flag,\n        column: ctx.column,\n        prev: ctx.prev\n      };\n    }\n\n    function pop(state) {\n      state.indent = state.ctx.indent;\n      state.ctx = state.ctx.prev;\n    }\n\n    return {\n      startState: function startState() {\n        return {\n          tokenize: tokenBase,\n          ctx: {\n            type: \"top\",\n            indent: -config.indentUnit,\n            flags: ALIGN_NO\n          },\n          indent: 0,\n          afterIdent: false\n        };\n      },\n      token: function token(stream, state) {\n        if (stream.sol()) {\n          if ((state.ctx.flags & 3) == 0) state.ctx.flags |= ALIGN_NO;\n          if (state.ctx.flags & BRACELESS) pop(state);\n          state.indent = stream.indentation();\n        }\n\n        if (stream.eatSpace()) return null;\n        var style = state.tokenize(stream, state);\n        if (style != \"comment\" && (state.ctx.flags & ALIGN_NO) == 0) setFlag(state, ALIGN_YES);\n        if ((curPunc == \";\" || curPunc == \"{\" || curPunc == \"}\") && state.ctx.type == \"block\") pop(state);\n        if (curPunc == \"{\") push(state, \"}\", stream);else if (curPunc == \"(\") {\n          push(state, \")\", stream);\n          if (state.afterIdent) state.ctx.argList = true;\n        } else if (curPunc == \"[\") push(state, \"]\", stream);else if (curPunc == \"block\") push(state, \"block\", stream);else if (curPunc == state.ctx.type) pop(state);else if (state.ctx.type == \"block\" && style != \"comment\") setFlag(state, BRACELESS);\n        state.afterIdent = style == \"variable\" || style == \"keyword\";\n        return style;\n      },\n      indent: function indent(state, textAfter) {\n        if (state.tokenize != tokenBase) return 0;\n        var firstChar = textAfter && textAfter.charAt(0),\n            ctx = state.ctx,\n            closing = firstChar == ctx.type;\n        if (ctx.flags & BRACELESS) ctx = ctx.prev;\n        if (ctx.type == \"block\") return ctx.indent + (firstChar == \"{\" ? 0 : config.indentUnit);else if (ctx.flags & ALIGN_YES) return ctx.column + (closing ? 0 : 1);else return ctx.indent + (closing ? 0 : config.indentUnit);\n      },\n      lineComment: \"#\"\n    };\n  });\n  CodeMirror.defineMIME(\"text/x-rsrc\", \"r\");\n});"],"sourceRoot":""}