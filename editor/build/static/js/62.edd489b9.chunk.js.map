{"version":3,"sources":["../node_modules/codemirror/mode/octave/octave.js"],"names":["CodeMirror","defineMode","wordRegexp","words","RegExp","join","singleOperators","singleDelimiters","doubleOperators","doubleDelimiters","tripleDelimiters","expressionEnd","identifiers","builtins","keywords","tokenTranspose","stream","state","sol","peek","tokenize","tokenBase","next","tokenComment","match","skipToEnd","eatSpace","m","startState","token","style","lineComment","fold","defineMIME","mod","__webpack_require__"],"mappings":"+EAOC,SAAAA,GACD,aAEAA,EAAAC,WAAA,oBACA,SAAAC,EAAAC,GACA,WAAAC,OAAA,MAAAD,EAAAE,KAAA,gBAGA,IAAAC,EAAA,IAAAF,OAAA,gCACAG,EAAA,IAAAH,OAAA,uBACAI,EAAA,IAAAJ,OAAA,6DACAK,EAAA,IAAAL,OAAA,wDACAM,EAAA,IAAAN,OAAA,kBACAO,EAAA,IAAAP,OAAA,aACAQ,EAAA,IAAAR,OAAA,iDACAS,EAAAX,EAAA,+fACAY,EAAAZ,EAAA,kQAEA,SAAAa,EAAAC,EAAAC,GACA,OAAAD,EAAAE,OAAA,MAAAF,EAAAG,QAMAF,EAAAG,SAAAC,EACAA,EAAAL,EAAAC,KANAD,EAAAM,OACAL,EAAAG,SAAAC,EACA,YAOA,SAAAE,EAAAP,EAAAC,GACA,OAAAD,EAAAQ,MAAA,UACAP,EAAAG,SAAAC,EACA,YAIAL,EAAAS,YACA,WAGA,SAAAJ,EAAAL,EAAAC,GAEA,GAAAD,EAAAU,WAAA,YAEA,GAAAV,EAAAQ,MAAA,MAGA,OAFAP,EAAAG,SAAAG,EACAP,EAAAS,YACA,UAGA,GAAAT,EAAAQ,MAAA,SAEA,OADAR,EAAAS,YACA,UAIA,GAAAT,EAAAQ,MAAA,kBACA,GAAAR,EAAAQ,MAAA,6BAEA,OADAR,EAAAI,SAAAC,EACA,SAKA,GAAAL,EAAAQ,MAAA,wCACA,eAKA,GAAAR,EAAAQ,MAAA,mCACA,eAMA,GAAAR,EAAAQ,MAAAtB,EAAA,4BACA,eAKA,IAAAyB,EAAAX,EAAAQ,MAAA,wBAAAR,EAAAQ,MAAA,uBAEA,OAAAG,EACAA,EAAA,2BAIAX,EAAAQ,MAAAV,GACA,UAKAE,EAAAQ,MAAAX,GACA,UAKAG,EAAAQ,MAAAZ,GACA,WAKAI,EAAAQ,MAAAlB,IAAAU,EAAAQ,MAAAhB,GACA,WAKAQ,EAAAQ,MAAAjB,IAAAS,EAAAQ,MAAAf,IAAAO,EAAAQ,MAAAd,GACA,KAKAM,EAAAQ,MAAAb,IACAM,EAAAG,SAAAL,EACA,OAKAC,EAAAM,OACA,SAIA,OACAM,WAAA,WACA,OACAR,SAAAC,IAGAQ,MAAA,SAAAb,EAAAC,GACA,IAAAa,EAAAb,EAAAG,SAAAJ,EAAAC,GAMA,MAJA,WAAAa,GAAA,aAAAA,IACAb,EAAAG,SAAAL,GAGAe,GAEAC,YAAA,IACAC,KAAA,YAGAhC,EAAAiC,WAAA,0BA1JAC,CAAQC,EAAQ","file":"static/js/62.edd489b9.chunk.js","sourcesContent":["// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n(function (mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);else // Plain browser env\n    mod(CodeMirror);\n})(function (CodeMirror) {\n  \"use strict\";\n\n  CodeMirror.defineMode(\"octave\", function () {\n    function wordRegexp(words) {\n      return new RegExp(\"^((\" + words.join(\")|(\") + \"))\\\\b\");\n    }\n\n    var singleOperators = new RegExp(\"^[\\\\+\\\\-\\\\*/&|\\\\^~<>!@'\\\\\\\\]\");\n    var singleDelimiters = new RegExp('^[\\\\(\\\\[\\\\{\\\\},:=;]');\n    var doubleOperators = new RegExp(\"^((==)|(~=)|(<=)|(>=)|(<<)|(>>)|(\\\\.[\\\\+\\\\-\\\\*/\\\\^\\\\\\\\]))\");\n    var doubleDelimiters = new RegExp(\"^((!=)|(\\\\+=)|(\\\\-=)|(\\\\*=)|(/=)|(&=)|(\\\\|=)|(\\\\^=))\");\n    var tripleDelimiters = new RegExp(\"^((>>=)|(<<=))\");\n    var expressionEnd = new RegExp(\"^[\\\\]\\\\)]\");\n    var identifiers = new RegExp(\"^[_A-Za-z\\xA1-\\uFFFF][_A-Za-z0-9\\xA1-\\uFFFF]*\");\n    var builtins = wordRegexp(['error', 'eval', 'function', 'abs', 'acos', 'atan', 'asin', 'cos', 'cosh', 'exp', 'log', 'prod', 'sum', 'log10', 'max', 'min', 'sign', 'sin', 'sinh', 'sqrt', 'tan', 'reshape', 'break', 'zeros', 'default', 'margin', 'round', 'ones', 'rand', 'syn', 'ceil', 'floor', 'size', 'clear', 'zeros', 'eye', 'mean', 'std', 'cov', 'det', 'eig', 'inv', 'norm', 'rank', 'trace', 'expm', 'logm', 'sqrtm', 'linspace', 'plot', 'title', 'xlabel', 'ylabel', 'legend', 'text', 'grid', 'meshgrid', 'mesh', 'num2str', 'fft', 'ifft', 'arrayfun', 'cellfun', 'input', 'fliplr', 'flipud', 'ismember']);\n    var keywords = wordRegexp(['return', 'case', 'switch', 'else', 'elseif', 'end', 'endif', 'endfunction', 'if', 'otherwise', 'do', 'for', 'while', 'try', 'catch', 'classdef', 'properties', 'events', 'methods', 'global', 'persistent', 'endfor', 'endwhile', 'printf', 'sprintf', 'disp', 'until', 'continue', 'pkg']); // tokenizers\n\n    function tokenTranspose(stream, state) {\n      if (!stream.sol() && stream.peek() === '\\'') {\n        stream.next();\n        state.tokenize = tokenBase;\n        return 'operator';\n      }\n\n      state.tokenize = tokenBase;\n      return tokenBase(stream, state);\n    }\n\n    function tokenComment(stream, state) {\n      if (stream.match(/^.*%}/)) {\n        state.tokenize = tokenBase;\n        return 'comment';\n      }\n\n      ;\n      stream.skipToEnd();\n      return 'comment';\n    }\n\n    function tokenBase(stream, state) {\n      // whitespaces\n      if (stream.eatSpace()) return null; // Handle one line Comments\n\n      if (stream.match('%{')) {\n        state.tokenize = tokenComment;\n        stream.skipToEnd();\n        return 'comment';\n      }\n\n      if (stream.match(/^[%#]/)) {\n        stream.skipToEnd();\n        return 'comment';\n      } // Handle Number Literals\n\n\n      if (stream.match(/^[0-9\\.+-]/, false)) {\n        if (stream.match(/^[+-]?0x[0-9a-fA-F]+[ij]?/)) {\n          stream.tokenize = tokenBase;\n          return 'number';\n        }\n\n        ;\n\n        if (stream.match(/^[+-]?\\d*\\.\\d+([EeDd][+-]?\\d+)?[ij]?/)) {\n          return 'number';\n        }\n\n        ;\n\n        if (stream.match(/^[+-]?\\d+([EeDd][+-]?\\d+)?[ij]?/)) {\n          return 'number';\n        }\n\n        ;\n      }\n\n      if (stream.match(wordRegexp(['nan', 'NaN', 'inf', 'Inf']))) {\n        return 'number';\n      }\n\n      ; // Handle Strings\n\n      var m = stream.match(/^\"(?:[^\"]|\"\")*(\"|$)/) || stream.match(/^'(?:[^']|'')*('|$)/);\n\n      if (m) {\n        return m[1] ? 'string' : \"string error\";\n      } // Handle words\n\n\n      if (stream.match(keywords)) {\n        return 'keyword';\n      }\n\n      ;\n\n      if (stream.match(builtins)) {\n        return 'builtin';\n      }\n\n      ;\n\n      if (stream.match(identifiers)) {\n        return 'variable';\n      }\n\n      ;\n\n      if (stream.match(singleOperators) || stream.match(doubleOperators)) {\n        return 'operator';\n      }\n\n      ;\n\n      if (stream.match(singleDelimiters) || stream.match(doubleDelimiters) || stream.match(tripleDelimiters)) {\n        return null;\n      }\n\n      ;\n\n      if (stream.match(expressionEnd)) {\n        state.tokenize = tokenTranspose;\n        return null;\n      }\n\n      ; // Handle non-detected items\n\n      stream.next();\n      return 'error';\n    }\n\n    ;\n    return {\n      startState: function startState() {\n        return {\n          tokenize: tokenBase\n        };\n      },\n      token: function token(stream, state) {\n        var style = state.tokenize(stream, state);\n\n        if (style === 'number' || style === 'variable') {\n          state.tokenize = tokenTranspose;\n        }\n\n        return style;\n      },\n      lineComment: '%',\n      fold: 'indent'\n    };\n  });\n  CodeMirror.defineMIME(\"text/x-octave\", \"octave\");\n});"],"sourceRoot":""}