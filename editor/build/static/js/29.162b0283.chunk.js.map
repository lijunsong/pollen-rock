{"version":3,"sources":["../node_modules/codemirror/mode/erlang/erlang.js"],"names":["CodeMirror","defineMIME","defineMode","cmCfg","typeWords","keywordWords","separatorRE","separatorWords","operatorAtomWords","operatorSymbolRE","operatorSymbolWords","openParenRE","openParenWords","closeParenRE","closeParenWords","guardWords","bifWords","anumRE","escapesRE","nongreedy","stream","re","words","current","length","test","backUp","peek","next","is_member","greedy","doubleQuote","quote","singleQuote","quoteChar","escapeChar","eol","ch","element","list","indexOf","rval","state","type","token","tokenStack","s","last","pop","push","maybe_drop_pre","slice","d","g","i","e","r","m","E","maybe_drop_post","pushToken","aToken","column","indentation","realToken","tok","col","ind","typ","indent","fakeToken","peekToken","depth","len","dep","stack","tt","tokens","ss","concat","indenter","textAfter","t","unit","indentUnit","wordAfter","str","match","truthy","index","wordafter","currT","prevT","in_string","in_atom","Pass","getToken","objs","getTokenIndex","postcommaToken","stop","oper","defaultToken","propname","propvals","x","startState","eatSpace","skipToEnd","eatWhile","w","lookahead","digitRE","eat","tokenizer","lineComment","mod","__webpack_require__"],"mappings":"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","file":"static/js/29.162b0283.chunk.js","sourcesContent":["// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n\n/*jshint unused:true, eqnull:true, curly:true, bitwise:true */\n\n/*jshint undef:true, latedef:true, trailing:true */\n\n/*global CodeMirror:true */\n// erlang mode.\n// tokenizer -> token types -> CodeMirror styles\n// tokenizer maintains a parse stack\n// indenter uses the parse stack\n// TODO indenter:\n//   bit syntax\n//   old guard/bif/conversion clashes (e.g. \"float/1\")\n//   type/spec/opaque\n(function (mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);else // Plain browser env\n    mod(CodeMirror);\n})(function (CodeMirror) {\n  \"use strict\";\n\n  CodeMirror.defineMIME(\"text/x-erlang\", \"erlang\");\n  CodeMirror.defineMode(\"erlang\", function (cmCfg) {\n    \"use strict\"; /////////////////////////////////////////////////////////////////////////////\n    // constants\n\n    var typeWords = [\"-type\", \"-spec\", \"-export_type\", \"-opaque\"];\n    var keywordWords = [\"after\", \"begin\", \"catch\", \"case\", \"cond\", \"end\", \"fun\", \"if\", \"let\", \"of\", \"query\", \"receive\", \"try\", \"when\"];\n    var separatorRE = /[\\->,;]/;\n    var separatorWords = [\"->\", \";\", \",\"];\n    var operatorAtomWords = [\"and\", \"andalso\", \"band\", \"bnot\", \"bor\", \"bsl\", \"bsr\", \"bxor\", \"div\", \"not\", \"or\", \"orelse\", \"rem\", \"xor\"];\n    var operatorSymbolRE = /[\\+\\-\\*\\/<>=\\|:!]/;\n    var operatorSymbolWords = [\"=\", \"+\", \"-\", \"*\", \"/\", \">\", \">=\", \"<\", \"=<\", \"=:=\", \"==\", \"=/=\", \"/=\", \"||\", \"<-\", \"!\"];\n    var openParenRE = /[<\\(\\[\\{]/;\n    var openParenWords = [\"<<\", \"(\", \"[\", \"{\"];\n    var closeParenRE = /[>\\)\\]\\}]/;\n    var closeParenWords = [\"}\", \"]\", \")\", \">>\"];\n    var guardWords = [\"is_atom\", \"is_binary\", \"is_bitstring\", \"is_boolean\", \"is_float\", \"is_function\", \"is_integer\", \"is_list\", \"is_number\", \"is_pid\", \"is_port\", \"is_record\", \"is_reference\", \"is_tuple\", \"atom\", \"binary\", \"bitstring\", \"boolean\", \"function\", \"integer\", \"list\", \"number\", \"pid\", \"port\", \"record\", \"reference\", \"tuple\"];\n    var bifWords = [\"abs\", \"adler32\", \"adler32_combine\", \"alive\", \"apply\", \"atom_to_binary\", \"atom_to_list\", \"binary_to_atom\", \"binary_to_existing_atom\", \"binary_to_list\", \"binary_to_term\", \"bit_size\", \"bitstring_to_list\", \"byte_size\", \"check_process_code\", \"contact_binary\", \"crc32\", \"crc32_combine\", \"date\", \"decode_packet\", \"delete_module\", \"disconnect_node\", \"element\", \"erase\", \"exit\", \"float\", \"float_to_list\", \"garbage_collect\", \"get\", \"get_keys\", \"group_leader\", \"halt\", \"hd\", \"integer_to_list\", \"internal_bif\", \"iolist_size\", \"iolist_to_binary\", \"is_alive\", \"is_atom\", \"is_binary\", \"is_bitstring\", \"is_boolean\", \"is_float\", \"is_function\", \"is_integer\", \"is_list\", \"is_number\", \"is_pid\", \"is_port\", \"is_process_alive\", \"is_record\", \"is_reference\", \"is_tuple\", \"length\", \"link\", \"list_to_atom\", \"list_to_binary\", \"list_to_bitstring\", \"list_to_existing_atom\", \"list_to_float\", \"list_to_integer\", \"list_to_pid\", \"list_to_tuple\", \"load_module\", \"make_ref\", \"module_loaded\", \"monitor_node\", \"node\", \"node_link\", \"node_unlink\", \"nodes\", \"notalive\", \"now\", \"open_port\", \"pid_to_list\", \"port_close\", \"port_command\", \"port_connect\", \"port_control\", \"pre_loaded\", \"process_flag\", \"process_info\", \"processes\", \"purge_module\", \"put\", \"register\", \"registered\", \"round\", \"self\", \"setelement\", \"size\", \"spawn\", \"spawn_link\", \"spawn_monitor\", \"spawn_opt\", \"split_binary\", \"statistics\", \"term_to_binary\", \"time\", \"throw\", \"tl\", \"trunc\", \"tuple_size\", \"tuple_to_list\", \"unlink\", \"unregister\", \"whereis\"]; // upper case: [A-Z] [Ø-Þ] [À-Ö]\n    // lower case: [a-z] [ß-ö] [ø-ÿ]\n\n    var anumRE = /[\\w@Ø-ÞÀ-Öß-öø-ÿ]/;\n    var escapesRE = /[0-7]{1,3}|[bdefnrstv\\\\\"']|\\^[a-zA-Z]|x[0-9a-zA-Z]{2}|x{[0-9a-zA-Z]+}/; /////////////////////////////////////////////////////////////////////////////\n    // tokenizer\n\n    function tokenizer(stream, state) {\n      // in multi-line string\n      if (state.in_string) {\n        state.in_string = !doubleQuote(stream);\n        return rval(state, stream, \"string\");\n      } // in multi-line atom\n\n\n      if (state.in_atom) {\n        state.in_atom = !singleQuote(stream);\n        return rval(state, stream, \"atom\");\n      } // whitespace\n\n\n      if (stream.eatSpace()) {\n        return rval(state, stream, \"whitespace\");\n      } // attributes and type specs\n\n\n      if (!peekToken(state) && stream.match(/-\\s*[a-zß-öø-ÿ][\\wØ-ÞÀ-Öß-öø-ÿ]*/)) {\n        if (is_member(stream.current(), typeWords)) {\n          return rval(state, stream, \"type\");\n        } else {\n          return rval(state, stream, \"attribute\");\n        }\n      }\n\n      var ch = stream.next(); // comment\n\n      if (ch == '%') {\n        stream.skipToEnd();\n        return rval(state, stream, \"comment\");\n      } // colon\n\n\n      if (ch == \":\") {\n        return rval(state, stream, \"colon\");\n      } // macro\n\n\n      if (ch == '?') {\n        stream.eatSpace();\n        stream.eatWhile(anumRE);\n        return rval(state, stream, \"macro\");\n      } // record\n\n\n      if (ch == \"#\") {\n        stream.eatSpace();\n        stream.eatWhile(anumRE);\n        return rval(state, stream, \"record\");\n      } // dollar escape\n\n\n      if (ch == \"$\") {\n        if (stream.next() == \"\\\\\" && !stream.match(escapesRE)) {\n          return rval(state, stream, \"error\");\n        }\n\n        return rval(state, stream, \"number\");\n      } // dot\n\n\n      if (ch == \".\") {\n        return rval(state, stream, \"dot\");\n      } // quoted atom\n\n\n      if (ch == '\\'') {\n        if (!(state.in_atom = !singleQuote(stream))) {\n          if (stream.match(/\\s*\\/\\s*[0-9]/, false)) {\n            stream.match(/\\s*\\/\\s*[0-9]/, true);\n            return rval(state, stream, \"fun\"); // 'f'/0 style fun\n          }\n\n          if (stream.match(/\\s*\\(/, false) || stream.match(/\\s*:/, false)) {\n            return rval(state, stream, \"function\");\n          }\n        }\n\n        return rval(state, stream, \"atom\");\n      } // string\n\n\n      if (ch == '\"') {\n        state.in_string = !doubleQuote(stream);\n        return rval(state, stream, \"string\");\n      } // variable\n\n\n      if (/[A-Z_Ø-ÞÀ-Ö]/.test(ch)) {\n        stream.eatWhile(anumRE);\n        return rval(state, stream, \"variable\");\n      } // atom/keyword/BIF/function\n\n\n      if (/[a-z_ß-öø-ÿ]/.test(ch)) {\n        stream.eatWhile(anumRE);\n\n        if (stream.match(/\\s*\\/\\s*[0-9]/, false)) {\n          stream.match(/\\s*\\/\\s*[0-9]/, true);\n          return rval(state, stream, \"fun\"); // f/0 style fun\n        }\n\n        var w = stream.current();\n\n        if (is_member(w, keywordWords)) {\n          return rval(state, stream, \"keyword\");\n        } else if (is_member(w, operatorAtomWords)) {\n          return rval(state, stream, \"operator\");\n        } else if (stream.match(/\\s*\\(/, false)) {\n          // 'put' and 'erlang:put' are bifs, 'foo:put' is not\n          if (is_member(w, bifWords) && (peekToken(state).token != \":\" || peekToken(state, 2).token == \"erlang\")) {\n            return rval(state, stream, \"builtin\");\n          } else if (is_member(w, guardWords)) {\n            return rval(state, stream, \"guard\");\n          } else {\n            return rval(state, stream, \"function\");\n          }\n        } else if (lookahead(stream) == \":\") {\n          if (w == \"erlang\") {\n            return rval(state, stream, \"builtin\");\n          } else {\n            return rval(state, stream, \"function\");\n          }\n        } else if (is_member(w, [\"true\", \"false\"])) {\n          return rval(state, stream, \"boolean\");\n        } else {\n          return rval(state, stream, \"atom\");\n        }\n      } // number\n\n\n      var digitRE = /[0-9]/;\n      var radixRE = /[0-9a-zA-Z]/; // 36#zZ style int\n\n      if (digitRE.test(ch)) {\n        stream.eatWhile(digitRE);\n\n        if (stream.eat('#')) {\n          // 36#aZ  style integer\n          if (!stream.eatWhile(radixRE)) {\n            stream.backUp(1); //\"36#\" - syntax error\n          }\n        } else if (stream.eat('.')) {\n          // float\n          if (!stream.eatWhile(digitRE)) {\n            stream.backUp(1); // \"3.\" - probably end of function\n          } else {\n            if (stream.eat(/[eE]/)) {\n              // float with exponent\n              if (stream.eat(/[-+]/)) {\n                if (!stream.eatWhile(digitRE)) {\n                  stream.backUp(2); // \"2e-\" - syntax error\n                }\n              } else {\n                if (!stream.eatWhile(digitRE)) {\n                  stream.backUp(1); // \"2e\" - syntax error\n                }\n              }\n            }\n          }\n        }\n\n        return rval(state, stream, \"number\"); // normal integer\n      } // open parens\n\n\n      if (nongreedy(stream, openParenRE, openParenWords)) {\n        return rval(state, stream, \"open_paren\");\n      } // close parens\n\n\n      if (nongreedy(stream, closeParenRE, closeParenWords)) {\n        return rval(state, stream, \"close_paren\");\n      } // separators\n\n\n      if (greedy(stream, separatorRE, separatorWords)) {\n        return rval(state, stream, \"separator\");\n      } // operators\n\n\n      if (greedy(stream, operatorSymbolRE, operatorSymbolWords)) {\n        return rval(state, stream, \"operator\");\n      }\n\n      return rval(state, stream, null);\n    } /////////////////////////////////////////////////////////////////////////////\n    // utilities\n\n\n    function nongreedy(stream, re, words) {\n      if (stream.current().length == 1 && re.test(stream.current())) {\n        stream.backUp(1);\n\n        while (re.test(stream.peek())) {\n          stream.next();\n\n          if (is_member(stream.current(), words)) {\n            return true;\n          }\n        }\n\n        stream.backUp(stream.current().length - 1);\n      }\n\n      return false;\n    }\n\n    function greedy(stream, re, words) {\n      if (stream.current().length == 1 && re.test(stream.current())) {\n        while (re.test(stream.peek())) {\n          stream.next();\n        }\n\n        while (0 < stream.current().length) {\n          if (is_member(stream.current(), words)) {\n            return true;\n          } else {\n            stream.backUp(1);\n          }\n        }\n\n        stream.next();\n      }\n\n      return false;\n    }\n\n    function doubleQuote(stream) {\n      return quote(stream, '\"', '\\\\');\n    }\n\n    function singleQuote(stream) {\n      return quote(stream, '\\'', '\\\\');\n    }\n\n    function quote(stream, quoteChar, escapeChar) {\n      while (!stream.eol()) {\n        var ch = stream.next();\n\n        if (ch == quoteChar) {\n          return true;\n        } else if (ch == escapeChar) {\n          stream.next();\n        }\n      }\n\n      return false;\n    }\n\n    function lookahead(stream) {\n      var m = stream.match(/([\\n\\s]+|%[^\\n]*\\n)*(.)/, false);\n      return m ? m.pop() : \"\";\n    }\n\n    function is_member(element, list) {\n      return -1 < list.indexOf(element);\n    }\n\n    function rval(state, stream, type) {\n      // parse stack\n      pushToken(state, realToken(type, stream)); // map erlang token type to CodeMirror style class\n      //     erlang             -> CodeMirror tag\n\n      switch (type) {\n        case \"atom\":\n          return \"atom\";\n\n        case \"attribute\":\n          return \"attribute\";\n\n        case \"boolean\":\n          return \"atom\";\n\n        case \"builtin\":\n          return \"builtin\";\n\n        case \"close_paren\":\n          return null;\n\n        case \"colon\":\n          return null;\n\n        case \"comment\":\n          return \"comment\";\n\n        case \"dot\":\n          return null;\n\n        case \"error\":\n          return \"error\";\n\n        case \"fun\":\n          return \"meta\";\n\n        case \"function\":\n          return \"tag\";\n\n        case \"guard\":\n          return \"property\";\n\n        case \"keyword\":\n          return \"keyword\";\n\n        case \"macro\":\n          return \"variable-2\";\n\n        case \"number\":\n          return \"number\";\n\n        case \"open_paren\":\n          return null;\n\n        case \"operator\":\n          return \"operator\";\n\n        case \"record\":\n          return \"bracket\";\n\n        case \"separator\":\n          return null;\n\n        case \"string\":\n          return \"string\";\n\n        case \"type\":\n          return \"def\";\n\n        case \"variable\":\n          return \"variable\";\n\n        default:\n          return null;\n      }\n    }\n\n    function aToken(tok, col, ind, typ) {\n      return {\n        token: tok,\n        column: col,\n        indent: ind,\n        type: typ\n      };\n    }\n\n    function realToken(type, stream) {\n      return aToken(stream.current(), stream.column(), stream.indentation(), type);\n    }\n\n    function fakeToken(type) {\n      return aToken(type, 0, 0, type);\n    }\n\n    function peekToken(state, depth) {\n      var len = state.tokenStack.length;\n      var dep = depth ? depth : 1;\n\n      if (len < dep) {\n        return false;\n      } else {\n        return state.tokenStack[len - dep];\n      }\n    }\n\n    function pushToken(state, token) {\n      if (!(token.type == \"comment\" || token.type == \"whitespace\")) {\n        state.tokenStack = maybe_drop_pre(state.tokenStack, token);\n        state.tokenStack = maybe_drop_post(state.tokenStack);\n      }\n    }\n\n    function maybe_drop_pre(s, token) {\n      var last = s.length - 1;\n\n      if (0 < last && s[last].type === \"record\" && token.type === \"dot\") {\n        s.pop();\n      } else if (0 < last && s[last].type === \"group\") {\n        s.pop();\n        s.push(token);\n      } else {\n        s.push(token);\n      }\n\n      return s;\n    }\n\n    function maybe_drop_post(s) {\n      if (!s.length) return s;\n      var last = s.length - 1;\n\n      if (s[last].type === \"dot\") {\n        return [];\n      }\n\n      if (last > 1 && s[last].type === \"fun\" && s[last - 1].token === \"fun\") {\n        return s.slice(0, last - 1);\n      }\n\n      switch (s[last].token) {\n        case \"}\":\n          return d(s, {\n            g: [\"{\"]\n          });\n\n        case \"]\":\n          return d(s, {\n            i: [\"[\"]\n          });\n\n        case \")\":\n          return d(s, {\n            i: [\"(\"]\n          });\n\n        case \">>\":\n          return d(s, {\n            i: [\"<<\"]\n          });\n\n        case \"end\":\n          return d(s, {\n            i: [\"begin\", \"case\", \"fun\", \"if\", \"receive\", \"try\"]\n          });\n\n        case \",\":\n          return d(s, {\n            e: [\"begin\", \"try\", \"when\", \"->\", \",\", \"(\", \"[\", \"{\", \"<<\"]\n          });\n\n        case \"->\":\n          return d(s, {\n            r: [\"when\"],\n            m: [\"try\", \"if\", \"case\", \"receive\"]\n          });\n\n        case \";\":\n          return d(s, {\n            E: [\"case\", \"fun\", \"if\", \"receive\", \"try\", \"when\"]\n          });\n\n        case \"catch\":\n          return d(s, {\n            e: [\"try\"]\n          });\n\n        case \"of\":\n          return d(s, {\n            e: [\"case\"]\n          });\n\n        case \"after\":\n          return d(s, {\n            e: [\"receive\", \"try\"]\n          });\n\n        default:\n          return s;\n      }\n    }\n\n    function d(stack, tt) {\n      // stack is a stack of Token objects.\n      // tt is an object; {type:tokens}\n      // type is a char, tokens is a list of token strings.\n      // The function returns (possibly truncated) stack.\n      // It will descend the stack, looking for a Token such that Token.token\n      //  is a member of tokens. If it does not find that, it will normally (but\n      //  see \"E\" below) return stack. If it does find a match, it will remove\n      //  all the Tokens between the top and the matched Token.\n      // If type is \"m\", that is all it does.\n      // If type is \"i\", it will also remove the matched Token and the top Token.\n      // If type is \"g\", like \"i\", but add a fake \"group\" token at the top.\n      // If type is \"r\", it will remove the matched Token, but not the top Token.\n      // If type is \"e\", it will keep the matched Token but not the top Token.\n      // If type is \"E\", it behaves as for type \"e\", except if there is no match,\n      //  in which case it will return an empty stack.\n      for (var type in tt) {\n        var len = stack.length - 1;\n        var tokens = tt[type];\n\n        for (var i = len - 1; -1 < i; i--) {\n          if (is_member(stack[i].token, tokens)) {\n            var ss = stack.slice(0, i);\n\n            switch (type) {\n              case \"m\":\n                return ss.concat(stack[i]).concat(stack[len]);\n\n              case \"r\":\n                return ss.concat(stack[len]);\n\n              case \"i\":\n                return ss;\n\n              case \"g\":\n                return ss.concat(fakeToken(\"group\"));\n\n              case \"E\":\n                return ss.concat(stack[i]);\n\n              case \"e\":\n                return ss.concat(stack[i]);\n            }\n          }\n        }\n      }\n\n      return type == \"E\" ? [] : stack;\n    } /////////////////////////////////////////////////////////////////////////////\n    // indenter\n\n\n    function indenter(state, textAfter) {\n      var t;\n      var unit = cmCfg.indentUnit;\n      var wordAfter = wordafter(textAfter);\n      var currT = peekToken(state, 1);\n      var prevT = peekToken(state, 2);\n\n      if (state.in_string || state.in_atom) {\n        return CodeMirror.Pass;\n      } else if (!prevT) {\n        return 0;\n      } else if (currT.token == \"when\") {\n        return currT.column + unit;\n      } else if (wordAfter === \"when\" && prevT.type === \"function\") {\n        return prevT.indent + unit;\n      } else if (wordAfter === \"(\" && currT.token === \"fun\") {\n        return currT.column + 3;\n      } else if (wordAfter === \"catch\" && (t = getToken(state, [\"try\"]))) {\n        return t.column;\n      } else if (is_member(wordAfter, [\"end\", \"after\", \"of\"])) {\n        t = getToken(state, [\"begin\", \"case\", \"fun\", \"if\", \"receive\", \"try\"]);\n        return t ? t.column : CodeMirror.Pass;\n      } else if (is_member(wordAfter, closeParenWords)) {\n        t = getToken(state, openParenWords);\n        return t ? t.column : CodeMirror.Pass;\n      } else if (is_member(currT.token, [\",\", \"|\", \"||\"]) || is_member(wordAfter, [\",\", \"|\", \"||\"])) {\n        t = postcommaToken(state);\n        return t ? t.column + t.token.length : unit;\n      } else if (currT.token == \"->\") {\n        if (is_member(prevT.token, [\"receive\", \"case\", \"if\", \"try\"])) {\n          return prevT.column + unit + unit;\n        } else {\n          return prevT.column + unit;\n        }\n      } else if (is_member(currT.token, openParenWords)) {\n        return currT.column + currT.token.length;\n      } else {\n        t = defaultToken(state);\n        return truthy(t) ? t.column + unit : 0;\n      }\n    }\n\n    function wordafter(str) {\n      var m = str.match(/,|[a-z]+|\\}|\\]|\\)|>>|\\|+|\\(/);\n      return truthy(m) && m.index === 0 ? m[0] : \"\";\n    }\n\n    function postcommaToken(state) {\n      var objs = state.tokenStack.slice(0, -1);\n      var i = getTokenIndex(objs, \"type\", [\"open_paren\"]);\n      return truthy(objs[i]) ? objs[i] : false;\n    }\n\n    function defaultToken(state) {\n      var objs = state.tokenStack;\n      var stop = getTokenIndex(objs, \"type\", [\"open_paren\", \"separator\", \"keyword\"]);\n      var oper = getTokenIndex(objs, \"type\", [\"operator\"]);\n\n      if (truthy(stop) && truthy(oper) && stop < oper) {\n        return objs[stop + 1];\n      } else if (truthy(stop)) {\n        return objs[stop];\n      } else {\n        return false;\n      }\n    }\n\n    function getToken(state, tokens) {\n      var objs = state.tokenStack;\n      var i = getTokenIndex(objs, \"token\", tokens);\n      return truthy(objs[i]) ? objs[i] : false;\n    }\n\n    function getTokenIndex(objs, propname, propvals) {\n      for (var i = objs.length - 1; -1 < i; i--) {\n        if (is_member(objs[i][propname], propvals)) {\n          return i;\n        }\n      }\n\n      return false;\n    }\n\n    function truthy(x) {\n      return x !== false && x != null;\n    } /////////////////////////////////////////////////////////////////////////////\n    // this object defines the mode\n\n\n    return {\n      startState: function startState() {\n        return {\n          tokenStack: [],\n          in_string: false,\n          in_atom: false\n        };\n      },\n      token: function token(stream, state) {\n        return tokenizer(stream, state);\n      },\n      indent: function indent(state, textAfter) {\n        return indenter(state, textAfter);\n      },\n      lineComment: \"%\"\n    };\n  });\n});"],"sourceRoot":""}